# 机器学习期末复习大纲

## 线性回归（Linear Regression）

### 核心概念和定义

* **监督学习用于回归**：线性回归属于监督学习，用于预测连续数值型标签。模型假设输出是输入特征的线性加权和，即假设函数形式为 $f_\theta(x) = \theta_0 + \theta_1 x_1 + \dots + \theta_n x_n$。通过学习参数 $\theta$ 来使模型输出尽可能接近真实标签。
* **假设空间与模型表示**：线性回归的假设空间是所有线性函数集合。模型参数 ${\theta_j}$ 决定了具体的线性函数形式。通过训练数据来调节参数，使得对于每个训练样本 $(x^{(i)}, y^{(i)})$，都有 $f_\theta(x^{(i)}) \approx y^{(i)}$。模型易于理解，计算上高效，在特征与输出存在线性关系时表现良好。
* **应用场景**：常见应用如房价预测（根据面积等特征）、销售额预测（根据广告投入）等。线性回归适合于近似线性关系的数据，当特征和目标之间关系接近线性时效果较好。

### 重点公式推导

* **损失函数（均方误差）**：采用均方误差(Mean Squared Error, MSE)衡量模型预测误差：$J(\theta_0,\dots,\theta_n) = \frac{1}{2N}\sum_{i=1}^{N}\big(f_\theta(x^{(i)}) - y^{(i)}\big)^2$。这里 $N$ 是训练样本数，系数 $\frac{1}{2}$ 便于求导时抵消平方项的2。
* **参数求解（梯度下降）**：通过**梯度下降**法最小化损失函数。对每个参数求偏导，可得参数更新规则：$\displaystyle \theta_j := \theta_j - \alpha \frac{1}{N}\sum_{i=1}^{N}\big(f_\theta(x^{(i)}) - y^{(i)}\big)x_j^{(i)}$。其中 $\alpha$ 是学习率，$x_0^{(i)}=1$（对应截距项）。梯度下降迭代更新参数使损失下降，直至收敛到最小值。
* **参数求解（正规方程）**：对损失函数求导设为0可直接求得**解析解**：$\nabla_\theta J(\theta)=0 \Rightarrow X^T X\,\theta = X^T y$，若矩阵 $X^T X$ 可逆，则解为 $\theta = (X^T X)^{-1}X^T y$。这被称为正规方程解（Normal Equation），一次计算直接得到全局最优解。
* **模型评估**：线性回归常用均方误差(MSE)或均方根误差(RMSE)评估拟合好坏。$R^2$（判定系数）也是常用指标，反映模型对变异的解释程度。训练时可通过损失随迭代下降曲线判断模型是否收敛。

### 典型例题与解法简要归纳

* **示例1：单变量房价预测**：给定若干房屋的面积（特征）和售价（标签），建立单变量线性回归模型 $f_\theta(x)=\theta_0+\theta_1 x$。解题步骤：① 将数据标准化以提高收敛速度；② 使用梯度下降更新 $\theta_0,\theta_1$，不断迭代直到误差收敛；③ 得到拟合的直线方程，如 $price = \theta_0 + \theta_1 \times size$。预测时将面积代入方程得到房价预测。
* **示例2：多变量预测**：如根据面积、卧室数预测房价。假设模型 $f_\theta(x)=\theta_0+\theta_1 x_{\text{面积}}+\theta_2 x_{\text{卧室}}$。通过正规方程一次算出参数：$\theta = (X^T X)^{-1}X^T y$（若可逆）节省迭代过程。对于小数据集，手算矩阵也可得到解；大数据集则可编程求解。
* **解法比较**：梯度下降需要选择学习率和迭代，适用于大规模数据和特征较多情况；正规方程直接求解更简洁，但在 $X^T X$ 不可逆或计算量过大（$O(n^3)$）时不适用。比如，当特征数$n$较小且样本适中时，可优先正规方程；而特征数或样本数巨大时，梯度下降更为可行。

### 易混淆点与常见错误

* **分类与回归混淆**：线性回归只能用于数值预测，**不能直接用于分类**问题。如果将线性模型用于二分类，会因输出未限定在$[0,1]$而无法直接当概率解释，此时应使用逻辑回归等方法。
* **非线性关系误用线性模型**：当特征与目标关系显著非线性时，直接用线性回归拟合会产生较大偏差。常见错误是遇到弯曲趋势的数据仍强行套用线性模型，应改用多项式回归（本质仍是参数的线性模型）或者其他非线性模型。
* **漏掉截距项**：忘记在模型中包含$\theta_0$（截距）会导致拟合不准确，除非数据均已中心化。截距项允许模型对整体偏移进行拟合，常见错误是在构造矩阵$X$时漏掉全1列对应$\theta_0$。
* **梯度下降收敛问题**：学习率选择不当是常见错误。$\alpha$过大会导致梯度下降不收敛甚至发散，过小则收敛缓慢。应通过观察损失下降曲线调整$\alpha$，必要时使用学习率衰减或自适应优化算法。
* **矩阵不可逆问题**：计算正规方程时，可能出现$X^T X$不可逆（如特征冗余导致列相关）。此时常见解决办法是应用正则化（如岭回归加入惩罚项使矩阵变为满秩）或在求解前去除共线性特征。

### 期末考试高频考点与建议记忆点

* **线性回归公式**：牢记假设函数 $f_\theta(x)$ 的形式和*MSE*损失函数公式。考试常要求写出或识别这些基本公式。
* **推导题**：正规方程的推导是高频考点。从$J(\theta)$对$\theta$求导并令其为0，推导出$X^T X\,\theta = X^T y$ 的过程需理解，会简单矩阵求导推导步骤。
* **梯度下降更新**：需要记住梯度下降参数更新公式及其推导过程。特别是单变量情况下$\theta_0,\theta_1$更新公式，以及多变量的一般形式。可能会考察对更新公式的应用或变形。
* **梯度下降 vs 正规方程**：理解两种求解方法的区别。考试可能问及何时采用迭代法、何时用解析解，以及各自优缺点（如梯度下降适用于大规模数据、可在线学习，正规方程一次计算全局最优但对内存要求高等）。
* **模型假设与适用性**：需记忆线性回归隐含的一些基本假设（如噪声满足正态分布、各特征与目标近线性关系）。虽然课程重点不深究统计假设，但了解这些有助于理解模型局限。考试侧重应用层面时，更多会问何时线性模型有效、何时需要引入多项式项或其他非线性模型来提高拟合。

## 线性分类（Logistic Regression 等）

### 核心概念和定义

* **逻辑回归概念**：线性分类的典型模型是**逻辑斯蒂回归**（Logistic Regression），用于二分类问题。它在线性模型的基础上通过**Sigmoid函数**将输出映射为概率值：$f_\theta(x) = \frac{1}{1+e^{-\theta^T x}}$。输出值范围在0到1，可解释为预测为“正类”的概率。逻辑回归本质是**判别模型**，直接对后验概率建模。
* **决策边界**：逻辑回归的决策规则是根据概率取阈值（通常0.5）。当 $f_\theta(x) \ge 0.5$ 时预测正类（1），否则预测负类（0）。由于$\sigma(z)=0.5$对应$z=0$，阈值0.5等价于**线性判别条件** $\theta^T x = 0$。因此决策边界是特征空间中的一个与参数$\theta$有关的超平面，对于二元特征就是一条直线。
* **模型训练目标**：逻辑回归通过极大化训练数据的**似然函数**（等价于最小化对数损失）来学习参数。因为没有闭式解，一般使用数值优化（如梯度下降或牛顿法）迭代求解参数使得训练样本的对数似然 $\sum_i \ln P(y^{(i)}|x^{(i)})$ 最大。
* **多分类扩展**：线性分类可扩展到多类别。常见方法有：① **Softmax回归**（多项逻辑回归），直接将线性函数输出通过Softmax计算属于各类的概率；② **一对多**（One-vs-Rest, OvR）训练多个二分类器，每次将其中一类当正类、其他当负类，再综合决策；③ **一对一**（One-vs-One, OvO）为每对类别训练分类器，由投票决定归属。Softmax回归在数学上是一种广义的逻辑回归，可同时输出$K$个类别的概率分布。

### 重点公式推导

* **Sigmoid函数性质**：Sigmoid（逻辑函数）定义为 $\sigma(z) = \frac{1}{1+e^{-z}}$。它的导数 $\sigma'(z) = \sigma(z)\big(1-\sigma(z)\big)$ 在推导梯度时很重要。当使用均方误差会导致非凸，这也是逻辑回归不采用MSE作为损失的原因之一。
* **对数损失函数**：逻辑回归采用对数似然对应的损失函数（交叉熵损失）：$L(f_\theta(x), y) = -\big[y\ln f_\theta(x) + (1-y)\ln(1 - f_\theta(x))\big]$。其中$y\in{0,1}$是真实类别，$f_\theta(x)$是预测为1的概率。这一损失函数在$y=1$时取$-\ln p$，$y=0$时取$-\ln(1-p)$，确保预测概率越接近正确类别，损失越小。
* **梯度推导**：交叉熵损失关于参数$\theta$的导数推导是重点。以单个样本为例，其梯度为$\frac{\partial L}{\partial \theta} = (f_\theta(x)-y)\,x$。将其推广到全数据集，梯度为$\frac{1}{N}\sum_{i=1}^N\big(f_\theta(x^{(i)}) - y^{(i)}\big)x^{(i)}$，形式与线性回归梯度类似，只是误差项由$f_\theta(x)-y$构成。这推导利用了$\sigma'(\theta^T x) = \sigma(\theta^T x)(1-\sigma(\theta^T x))$，在推导过程中会抵消，得到简洁的结果。
* **参数求解**：因为逻辑回归的损失函数是凸函数，没有解析解，需用梯度下降或更快的**牛顿法**（Newton-Raphson）迭代更新参数。梯度下降更新与线性回归形式类似，只是误差项不同；而牛顿法利用二阶导数信息，每步更新$\theta := \theta - H^{-1} g$（$H$为Hessian矩阵，$g$为梯度），收敛速度更快，但计算Hessian代价高，一般用于小规模数据集。
* **评价指标**：训练完成后，可通过**对数似然值**或**损失值**是否收敛判断是否拟合充分。分类性能通常用准确率(Accuracy)、精确率/召回率(Precision/Recall)、F1值等衡量，逻辑回归输出概率也方便计算ROC曲线和AUC等指标来评价分类器的判别能力。

### 典型例题与解法简要归纳

* **示例1：好瓜鉴别**：使用西瓜数据集（如周志华《机器学习》中的“好瓜/坏瓜”样本），特征包括色泽、敲声等类别属性，目标是预测好瓜(1)或坏瓜(0)。可以将类别特征用0/1编码，再训练逻辑回归模型。求解时用梯度下降更新参数，迭代直到损失收敛。最终模型能给出一个好瓜的概率，预测时取0.5为阈值判断。这种例题考查对逻辑回归的应用，涉及特征编码、模型训练及阈值决策的完整流程。
* **示例2：学生考试通过率预测**：特征为平时成绩和出勤率，标签为是否通过考试。由于这是二分类，可以采用逻辑回归。训练时根据历史数据（通过或未通过）学习$\theta$。如果得到模型 $P(\text{pass}|x) = \sigma(-6 + 0.1x_1 + 0.5x_2)$（$x_1$平时分，$x_2$出勤率），那么对于新学生，计算$\theta^T x$取sigmoid得到通过概率，再根据阈值做出通过/不通过判定。解题关键是能正确计算出概率并阐述如何据此决策。
* **示例3：多类分类One-vs-Rest**：如同时预测学生成绩等级（优/良/及格/不及格）。可训练四个逻辑回归分类器，每个分类器针对一种等级 vs 其它，将输出概率最高的类别作为最终预测。这种一对其余策略要求理解如何组合多个二分类器解决多分类问题，考试中可能让描述实现过程或判定给定组合的结果。

### 易混淆点与常见错误

* **概率与阈值混淆**：新手常误以为逻辑回归直接输出类别。实际上模型输出的是属于正类的概率，需要根据阈值转换为具体类别。阈值通常默认0.5，但在类别不平衡时可调整阈值来平衡Precision/Recall。
* **逻辑回归与线性回归混淆**：逻辑回归虽然名字含“回归”但用于分类，区别在于逻辑回归通过Sigmoid将线性组合转换为概率。如果直接对分类标签用线性回归拟合会因假设不符而效果很差。因此应识别何时使用哪种模型，不要将逻辑回归当线性模型使用或反之。
* **损失函数取值**：有时会错误地使用均方误差作为分类损失。需注意逻辑回归应使用对数损失（交叉熵），以确保凸优化和良好性能。使用MSE会导致非凸且梯度容易陷入平坦区，不利于训练。
* **特征伸缩**：逻辑回归对极大或尺度差异大的特征数值会收敛缓慢。常见疏忽是未对数值特征进行归一化/标准化，导致训练过程振荡或收敛很慢。需养成对数值特征预处理的习惯。
* **过拟合**：虽然逻辑回归模型相对简单，仍可能在高维特征下过拟合。常见错误是未对模型做正则化（如L2正则项），导致参数过大记忆训练集噪声。应通过交叉验证选择正则化系数避免过拟合。

### 期末考试高频考点与建议记忆点

* **Sigmoid函数及公式**：需牢记Sigmoid的定义及其性质，尤其是$\sigma'(z) = \sigma(z)(1-\sigma(z))$，这是推导梯度的关键环节，考试可能以填空或选择形式考查。
* **对数损失函数**：记住逻辑回归损失函数表达式以及推导梯度的过程。考试常要求写出损失函数形式，理解其与最大似然的对应关系，以及为何选择该损失。
* **梯度推导与算法**：逻辑回归梯度下降算法步骤是考查重点，包括每次迭代如何利用当前$\theta$计算预测概率、损失和梯度，再更新参数。可能会给出一两个样本手算一轮梯度下降，需熟悉误差项$(f_\theta(x)-y)$的计算。
* **与Naive Bayes对比**：逻辑回归和朴素贝叶斯都是常用的分类方法，可能考查它们区别。应了解逻辑回归是判别模型直接学习$P(y|x)$，而朴素贝叶斯是生成模型利用$P(x|y)$通过贝叶斯定理计算后验。逻辑回归对输入特征无需独立假设，而朴素贝叶斯要求条件独立假设，这些区别要能简要说明。
* **多分类方法**：如果课程涉及Softmax回归或OvR/OvO策略，考试可能问“如何将二分类扩展到多分类”。要能够回答一种或两种方法并简述原理。例如Softmax公式及OvR策略的工作流程要心中有数，至少能描述步骤。

## 决策树（Decision Tree）

### 核心概念和定义

* **模型结构**：决策树是一种树形结构的分类与回归模型，由结点和有向边组成。**内部结点**表示对某特征的判断（如“色泽是否=青绿”），**分支**对应判断的结果（是/否或多分支），**叶结点**给出预测输出（类别标签或数值预测)。决策树通过对样本特征的**逐层划分**来实现预测，直观上相当于一组**if-else**规则的集合。
* **递归划分**：决策树学习采用**递归贪心**地划分数据集的策略：从根节点开始选择一个最优特征按某种准则划分数据，使各子节点变得**尽可能纯净**（同类样本占比高）。然后对子节点重复这一过程，构建子树，直到满足停止条件（如节点样本不可再分或纯度足够高）。这个自顶向下的构建过程又称**分治法**生成树。
* **划分准则**：常用的划分准则包括信息增益、信息增益率和基尼指数等。**信息增益**表示因划分使得**信息熵**（数据的不确定性）降低的程度；**信息增益率**是信息增益相对于特征取值熵的比率（用于惩罚取值过多的特征偏好）；**基尼指数**衡量数据被错误分类的概率。不同决策树算法采用不同准则：如ID3算法用信息增益、C4.5算法用信息增益率，CART算法用基尼指数。
* **优点**：决策树模型**可解释性强**，逻辑清晰，能直观地展示决策路径；对数据预处理要求低，可直接处理离散或连续特征（连续特征通过选阈值二分）；能够处理不平衡数据（可以通过代价敏感树调整）。预测时速度快，适合高维数据。但单棵树往往**泛化性能一般**，易过拟合，需要通过剪枝或集合方法提高性能。
* **应用**：决策树可用于分类（例如根据症状判别疾病）或回归（如根据房屋特征预测价格）。在很多集成模型（随机森林、梯度提升树）中，决策树也是基本组件。本课程主要关注分类树的构建原理和算法，对回归树原理相似（用方差或MSE做划分指标）。

### 重点公式推导

* **信息熵公式**：熵衡量样本集合的纯度，定义为 $Ent(D) = -\sum_{k=1}^K p_k \log_2 p_k$，其中$K$是类别数，$p_k$是集合$D$中属于第$k$类的样本比例。熵越小，说明集合纯度越高（大多样本同属一类）。在划分时，希望划分后子集的加权熵大幅降低。
* **信息增益公式**：选择特征$a$划分数据集$D$的信息增益定义为：$Gain(D,a) = Ent(D) - \sum_{v\in \text{Values}(a)} \frac{|D_v|}{|D|}Ent(D_v)$。其中$\text{Values}(a)$是特征$a$可能的取值集合，$D_v$是按$a=v$分得的子集。信息增益表示由于按特征$a$划分使得不确定性减少的量。ID3算法选择信息增益最大的特征作为当前节点划分依据。
* **信息增益率**：为减少偏好取值多特征的倾向，引入信息增益率：$Gain_ratio(D,a) = \frac{Gain(D,a)}{Ent(D) - \sum_{v} \frac{|D_v|}{|D|}\log_2\frac{|D_v|}{|D|}}$。分母称为$SplitInfo(a)$，表示特征$a$本身的熵（取值数量多则值大）。C4.5算法先找出信息增益高于平均水平的特征，再从中选择增益率最高的。
* **基尼指数**：CART决策树使用基尼指数作为划分指标。对于二分类问题，节点$D$的基尼值 $Gini(D) = 1 - (p^2 + (1-p)^2)$，$p$为正类比例。对于多分类，$Gini(D) = \sum_{k} \sum_{k'\neq k} p_k p_{k'} = 1-\sum_{k}p_k^2$，表示从集合中随机抽取两个样本其类别不同的概率。特征$a$的基尼指数定义为各可能切分结果的加权和：$Gini_index(D,a) = \sum_{v} \frac{|D_v|}{|D|}Gini(D_v)$。算法选择使基尼指数最小（纯度最高）的划分。
* **剪枝决策**：树生成后可能过深过拟合，需要**剪枝**降低复杂度。剪枝策略有预剪枝和后剪枝：预剪枝是在构建过程中提前停止，若当前划分无法显著提升信息增益则停止分裂，直接将节点作为叶节点分类；后剪枝是先生成完整树，再自下而上剪掉一些分支，用交叉验证或独立验证集评估剪枝前后准确率，保留对泛化有益的剪枝。后剪枝通常效果更佳但计算开销大。

### 典型例题与解法简要归纳

* **示例1：天气数据集构建树**：经典Play Tennis数据，特征包括天气Outlook（晴/阴/雨）、温度、湿度、有无风，目标是“是否打网球”。构建决策树：计算在根节点选哪个特征划分信息增益最高，例如Outlook的信息增益最高则作为根结点，根据晴/阴/雨分支；对子节点递归计算，如湿度或风等。最终得到决策规则集，如“如果Outlook=Sunny且Humidity=Normal则Play=Yes”等。解题过程需要计算熵和增益，选择划分，并画出简洁的树形结构。
* **示例2：西瓜数据集ID3算法**：西瓜数据（色泽、根蒂、敲声、纹理、脐部、触感等离散特征，标签好/坏瓜）。用ID3算法构建分类树：根节点计算每个特征对好瓜/坏瓜的不纯度降低，选信息增益最大的，比如“纹理”最高则根按纹理（清晰/稍糊/模糊）分3支，再对每支继续。这个例子考查对算法执行过程的掌握，包括如何计算每个特征的信息增益、如何划分直到叶节点纯度高（或无特征可分）。最后产出类似西瓜书中的决策树模型，考生需能够描述或列举其中规则。
* **示例3：连续特征划分**：给定一个包含连续属性的数据集，如“肿瘤大小”预测良/恶性。CART算法可尝试不同切分点（二分法）算基尼指数最低的切分，例如某阈值5将大小分为<=5和>5两组。如果阈值5给予最低基尼指数则采用该划分生成左右子树。此例考查如何处理连续值：需要将连续变量离散化为二值，对多个候选阈值尝试，计算指标找到最佳切分点。

### 易混淆点与常见错误

* **特征取值多寡的影响**：使用ID3算法时，信息增益偏好取值数目多的特征。学生易混淆这是因为更多取值会**过度划分**数据使熵降低，即使这种划分未必有意义。C4.5引入信息增益率修正这一偏好。因此在回答“为什么不用单纯的信息增益”时，要指出取值数影响。
* **过拟合与剪枝**：决策树若不限制深度容易拟合噪声。常见错误是忽略了剪枝的重要性，导致模型泛化性能差。要记得说明剪枝的作用：预剪枝通过提前停止避免树过深，可能欠拟合；后剪枝通过在完全长成的树上剪掉不显著的分支来降低过拟合风险。答题时如被问到防止过拟合措施，要将剪枝作为首要方法。
* **连续值处理**：有些同学可能误以为决策树无法处理连续特征。实际上可通过选取阈值将连续特征二分。例如CART在每个节点计算最佳切分值。忽视这一点会误答。需注意题目若涉及连续特征，应说明如何排序候选切分点并计算划分指标，不能简单离散化成区间而不解释依据。
* **空划分和多分支**：算法实现中可能出现子节点无数据（尤其连续值切分或缺失值处理)，实际应做平滑处理或停止划分。答题时提及如果出现某分支没有样本，可将该节点设为叶节点，类别由父节点多数表决。不然会认为回答的人没考虑完整。
* **决策树与线性模型区别**：部分人可能混淆树模型与线性模型。需要清楚指出决策树是**基于规则的非线性模型**，可以拟合更复杂的决策边界（非线性边界），不易受特征缩放影响；而线性模型决策边界是线性超平面。比较两者优缺点时，这些要点应当表明。

### 期末考试高频考点与建议记忆点

* **熵/增益计算**：考试经常给一小数据表，让计算某特征的信息熵、信息增益，选最优划分。需熟记熵和增益公式，练习手算。尤其是二分类熵计算（如正负样本概率$p$，熵$-p\log_2p-(1-p)\log_2(1-p)$）和根据划分结果算整体熵降低的过程。
* **ID3/C4.5/CART 区别**：可能会以问答形式要求说明三种算法的区别和联系。应记忆：ID3用信息增益、只能处理离散特征；C4.5用信息增益率、可处理连续特征和缺失值、生成多叉树；CART用基尼指数、只能二叉划分、可做分类回归统一处理。对比要点如**划分指标**、**树结构**、**结果类型**等要条理清晰地表述。
* **剪枝方法**：预剪枝和后剪枝原理与优缺点也是考试重点。记忆：预剪枝是在节点划分前评估划分收益，不明显就停止；后剪枝是在生成整棵树后自底向上剪除分支，以验证集性能为准。优点：预剪枝简单高效但易欠拟合，后剪枝效果好但需保留部分数据验证。回答时尽量说明采用何种评估（如信息增益阈值或验证集精度差异）。
* **决策树优缺点**：经常考简答。需要牢记的优点：可解释性强（规则可解释）、对数据预处理要求低、不用归一化、能处理离散连续属性、可以刻画非线性关系；缺点：容易过拟合（需剪枝）、对噪声敏感（微小数据变化可致树结构大变）、分段函数不光滑（预测结果离散）。可以在大脑中准备这些点，在考题问到时罗列。
* **随机森林提及**：虽然详细内容可能在集成学习部分，但可简单了解随机森林是多个决策树的集成，通过bagging提升泛化性能。如果问“如何提升单棵树性能”，可提随机森林作为关键词（训练多棵树取票决结果）来显示对课程内容的融会贯通。

## 支持向量机（Support Vector Machine，SVM）

### 核心概念和定义

* **最大间隔分类**：支持向量机是一种二分类模型，其核心思想是寻找能**最大化分类间隔**的分隔超平面。间隔定义为分类边界到离它最近的样本点的距离。SVM希望在保证训练样本正确分类的前提下，间隔越大越好，以提高对未知样本的鲁棒性。
* **支持向量**：在最终确定的超平面附近，正负两类距离边界最近的那些训练样本称为**支持向量**。这些支持向量恰好落在间隔边界上（对硬间隔SVM而言满足 $y_i(w^T x_i + b)=1$），它们对决策超平面的定位起决定作用。非支持向量（远离边界的样本）对超平面的位置没有直接影响。
* **硬间隔与软间隔**：若数据线性可分且对分类无错误要求，则为**硬间隔**最大化问题；而实际数据常有噪声或不可完全分，需允许少量错分，这引入了**软间隔**概念。在软间隔SVM中，对每个样本引入松弛变量$\epsilon_i \ge 0$，约束变为 $y_i(w^T x_i + b) \ge 1 - \epsilon_i$。同时在优化目标中增加对$\epsilon_i$的惩罚（如$\sum \epsilon_i$），权衡间隔最大和错误率最小。
* **核技巧**：SVM可以通过**核函数**处理线性不可分问题。核函数$K(x_i,x_j)$等价于在高维空间计算内积，而无需显式地进行高维映射。这允许SVM在原始特征经过隐式非线性映射后分类。常用核函数有线性核、多项式核、径向基核(RBF)等。核技巧使SVM能够构建非线性的决策边界，同时计算仍主要依赖内积运算。
* **目标优化**：基本的SVM学习可形式化为带约束的凸二次规划问题：**硬间隔**情况下，优化$\frac{1}{2}|w|^2$，约束$y_i(w^T x_i + b)\ge1$；**软间隔**则优化$\frac{1}{2}|w|^2 + C\sum \epsilon_i$，约束$y_i(w^T x_i + b)\ge1-\epsilon_i$。通过拉格朗日对偶和KKT条件可高效求解，对偶问题中拉格朗日乘子$\alpha_i$对应每个样本。最后模型预测由**决策函数** $f(x) = \operatorname{sign}{\sum_{i \in SV} \alpha_i y_i K(x_i, x) + b}$ 给出，仅与支持向量有关。

### 重点公式推导

* **间隔与几何解释**：对于任意分隔超平面$w^T x + b = 0$，规范化到经过支持向量且$w^T x + b = \pm1$，此时**几何间隔** = 正负边界之间距离 = $\frac{2}{|w|}$。推导时，通过两类支持向量坐标差$(x^{+}-x^{-})$在法向量方向的投影长度公式可得出间隔$= \frac{|w^T x^{+} + b - (w^T x^{-}+b)|}{|w|} = \frac{2}{|w|}$。这一结论解释了为何优化目标等价于最小化$|w|^2$。
* **拉格朗日对偶推导**：将原始优化问题引入拉格朗日乘子$\alpha_i$构建拉格朗日函数：$\mathcal{L}(w,b,\alpha)=\frac{1}{2}|w|^2 - \sum_{i}\alpha_i[y_i(w^T x_i+b)-1]$。对偶问题为极大化 $W(\alpha)=\sum_i \alpha_i - \frac{1}{2}\sum_{i,j}\alpha_i \alpha_j y_i y_j (x_i^T x_j)$，约束$\sum_i \alpha_i y_i=0,\ \alpha_i\ge0$。求解对偶可得$\alpha$值，再反求$w=\sum_i \alpha_i y_i x_i$。这推导体现SVM最终仅靠点积（内积）计算，便于引入核函数。
* **软间隔惩罚参数**：在软间隔对偶问题中，拉格朗日乘子$\alpha_i$有上界$C$（对应约束$\epsilon_i$）。当$0<\alpha_i<C$时样本刚好在边界上；$\alpha_i = C$表示样本位于错误侧（违反间隔要求，被过多地忽略一定程度上视为噪声）；$\alpha_i = 0$表示样本距边界远，对超平面无影响。理解这点有助于解释支持向量选择和松弛变量作用。
* **核函数条件**：需要注意并非任意函数都能当核用。**Mercer定理**给出了核函数需满足的条件：对应的核矩阵必须是半正定的（即对任意向量$\mathbf{z}$都有$\mathbf{z}^T K \mathbf{z} \ge 0$）。考试不要求记忆证明，但要知道常用核（线性、多项式、RBF、Sigmoid）都是符合条件的，可以安全使用。
* **多类SVM**：SVM本质是二分类模型，多类可通过OvR或OvO策略实现（类似逻辑回归的扩展方法）。有些SVM实现支持直接求多类，但原理通常是采用一对多或结构化SVM，不在本科考试重点。一般了解通过训练多个二分类器组合解决多分类即可。

### 典型例题与解法简要归纳

* **示例1：线性可分简单示例**：给出二维平面上一组点，两类可线性分，例如正类(红色)分布在右上角，负类(蓝色)在左下角。要求学生画出最大间隔分隔直线。解题要点：找到“中间地带”最宽的直线，使两边离最近点距离相等且最大。这涉及肉眼或简单计算确定支持向量（往往就是离对方类最近的点）并画出经过这些点的平行线，再取居中作为决策边界。此题考查理解间隔最大原则和支持向量概念。
* **示例2：软间隔参数影响**：给定一维可分数据，正类在$x>0$区域但有一个噪声点错误地出现在$x<0$。讨论SVM在不同$C$值下决策边界情况：当$C$很大时，模型倾向于硬间隔，尝试分类所有点但可能导致边界大幅移动；当$C$较小时，允许忽略噪声点（赋较大松弛$\epsilon$），超平面几乎按最大间隔位置放置。这个例子让学生理解$C$（惩罚系数）调整模型对误分类的容忍度，体现软间隔的作用。
* **示例3：核SVM判别**：如判定二维空间中**异或(XOR)问题**不可线性分，但通过映射到高维（如增加$x_1x_2$交叉项作为新特征）可线性分。考试可能不会让具体推导核映射，但可能给出XOR数据并问哪种核可分，如二次多项式核可以解决XOR。在回答时，需指出增加二次项或用多项式核能让SVM找到非线性边界，把数据分开。这个例子强调核技巧的威力：隐式映射扩展特征维度以解决非线性可分问题。

### 易混淆点与常见错误

* **间隔与泛化的关系**：部分学生可能不理解为何最大化间隔能提升泛化。可记忆“大间隔减少对训练点位置微小波动的敏感性”，因此模型更平滑稳定。答题涉及时，可举例说明如果决策边界贴近某训练点，轻微扰动会造成误分类，而大间隔模型更有“缓冲区”。
* **软间隔松弛变量误解**：有时误以为松弛变量$\epsilon_i$直接等同于误分类个数。实际上$\epsilon_i$表示样本未达到间隔的程度，$\epsilon_i>1$才意味着样本被误分类。多个$\epsilon_i$之和近似反映违反间隔总量但不等价于错分点数。回答关于软间隔问题时，要表述清楚$\epsilon_i$意义以及$C$与其的平衡作用：$C$大惩罚错分多，$C$小容忍错分。
* **支持向量误判**：学生可能以为所有训练样本都是支持向量。需强调只有**在间隔边界上或错误侧**的样本才是支持向量，其对应$\alpha_i>0$。多数样本距离边界远（函数间隔大于1）对模型不起作用（$\alpha=0$)。如果考试问“什么是支持向量”，要指出它们是“对超平面有支撑作用的少数关键样本”。
* **核函数选择**：常见混淆是核函数选错场景。例如线性数据用复杂核会过拟合，非线性数据却坚持线性核导致拟合不良。要理解核的作用和开销：核维度高计算慢且可能过拟合，所以选择时考虑数据量和线性可分性。若问到核技巧优势，也要提**避免显式映射**节省计算及**提升非线性建模能力**。
* **多分类SVM**：SVM原生是二类分类器，如果问“如何处理多分类”，回答里应包含如“一对多”或“一对一”等组合策略。有的同学可能不知道SVM需要这样扩展，误答成“修改目标函数处理多类”（实际需要更复杂的结构化SVM）。所以要清楚说明将问题转化为多个二分类来解决。

### 期末考试高频考点与建议记忆点

* **SVM优化问题公式**：要记牢硬间隔SVM的原始优化问题和约束条件，以及软间隔加入$\epsilon_i$的形式。考试可能让写出SVM的基本公式或解释各项含义（如$\frac{1}{2}|w|^2$为何表示最大间隔）。记忆这些公式对理解SVM机制很有帮助。
* **支持向量与决策函数**：常考概念题：“什么是支持向量”“SVM的决策函数形式”。应回答支持向量定义，并能写出决策函数 $f(x)=\operatorname{sign}{\sum_{i\in SV}\alpha_i y_i K(x_i,x)+b}$，说明预测依赖支持向量。即使记不全公式，也要描述出“分类决策由支持向量的拉格朗日乘子加权投票决定”这一思想。
* **核函数类型**：需记住几种常用核的名称和特点：线性核（线性模型），多项式核（可拟合多项式特征组合），高斯核RBF（有局部性，常用，需调节宽度参数$\gamma$），Sigmoid核（相当于NN激活函数）。有时考选择题会问“哪一个不是合法的核函数”或“哪种核适合处理哪种数据特点”，需对这些有所印象。
* **参数调节**：SVM的重要参数包括惩罚系数$C$和核函数自身参数（如RBF的$\gamma$）。考试可能不会深究网格搜索过程，但会问这些参数的作用。例如$C$大意味着更高训练准确率但可能过拟合，$C$小更平滑泛化好。$\gamma$大使RBF核更“窄”倾向记忆单点，$\gamma$小核更“宽”具有更强平滑性。这些定性理解在问答时可简单提及。
* **SVM与感知机/逻辑回归比较**：有时考题要求比较SVM与其他分类模型。要点：与感知机相比，SVM显式最大化间隔有更好泛化保障；与逻辑回归相比，SVM不直接输出概率而是距离（可用Platt缩放估计概率），逻辑回归对异常点鲁棒性稍弱但输出概率解释性强。另外SVM对高维小样本效果好（因为间隔最大化等价于结构风险最小化），这些都可作为论述点。

## 人工神经网络（Artificial Neural Network, ANN）

### 核心概念和定义

* **模型结构**：人工神经网络由仿生学**神经元**单元连接组成。每个**人工神经元**接受多个输入，加权求和并加上偏置，然后通过一个**激活函数**产生输出。典型的网络按层组织，分为**输入层**、**隐藏层**和**输出层**。输入层接收原始特征，隐藏层提取内部表示，输出层给出结果。多层神经网络（即**多层感知机**，MLP）本质上可视为复杂的复合函数，将输入映射到输出。
* **感知机与激活函数**：单个神经元模型（感知机）计算 $y = \sigma(\sum_i w_i x_i - b)$，其中$\sigma(\cdot)$是非线性激活函数。**激活函数**引入非线性，例如Sigmoid、tanh和ReLU等，使多层网络具备拟合非线性关系的能力。激活函数要求**连续可微且非线性**，以便误差反传求导。Sigmoid适用于输出概率，ReLU减轻梯度消失问题，是目前常用的隐藏层激活函数。
* **前向传播**：神经网络的预测计算通过**前向传播**完成。每层的每个神经元接收前一层输出作为输入，乘以权重加偏置，经过激活函数得到输出，再传递给下一层。层与层之间线性组合+非线性变换的重复，使网络可以表示高度非线性的映射关系。这种逐层计算最终得到输出层结果。前向传播过程等价于复合函数 $f(x) = f^{(L)}(f^{(L-1)}(...f^{(1)}(x)...))$ 的计算，其中$L$是层数。
* **学习目标**：神经网络训练的目标是找到各连接权重$w_{ij}$和偏置$b_i$，使网络对训练数据预测误差（通常用均方误差或交叉熵）最小。由于神经网络是非凸的复杂模型，训练采用迭代的**梯度下降**类算法，通过**误差反向传播**高效地计算梯度进行参数更新。训练过程中容易出现局部极小值和过拟合等，需要通过合理初始化、适当正则化和充分数据训练来缓解。
* **表达能力**：多层前馈网络在隐藏层节点和非线性激活充分时具有**通用逼近性**，理论上可逼近任何有限连续函数。但也意味着有能力过拟合训练数据，需要控制模型复杂度（层数、每层节点数）来取得偏差-方差权衡。浅层网络需要非常多的节点才能逼近复杂函数，深层网络通过逐级特征提取更高效，被誉为“特征自动学习”的模型。

### 重点公式推导

* **单层神经元输出**：一个神经元的输出计算公式：$a = \phi(z)$，其中 $z = \sum_{j} w_j x_j + b$，$\phi$表示激活函数。例如Sigmoid神经元：$a = \sigma(z) = \frac{1}{1+e^{-z}}$；ReLU神经元：$a = \max(0, z)$。了解各种激活函数的数学形式及导数是必要的，如$\sigma'(z)=\sigma(z)(1-\sigma(z))$、tanh导数$1-\tanh^2(z)$，ReLU导数为阶跃函数。这些为梯度计算做准备。
* **网络损失函数**：常用损失包括均方误差(MSE)（回归)和交叉熵(分类)。例如对于网络输出$\mathbf{y}$和真实$\mathbf{t}$，二分类交叉熵损失：$L = -[t\ln y + (1-t)\ln(1-y)]$。多分类交叉熵：$L = -\sum_{k} t_k \ln y_k$（其中$t_k$为第$k$类真实标签one-hot）。损失函数选择要与输出层激活匹配，如Softmax输出用交叉熵，使梯度计算简化。
* **反向传播算法**：反向传播（Backpropagation）是计算梯度的核心算法，其推导基于链式法则。以总损失$E$对参数的偏导为目标：首先根据输出层误差$\delta^{(L)}_i = \frac{\partial E}{\partial z^{(L)}_i}$开始，逐层向后计算隐藏层误差$\delta^{(l)} = ((W^{(l+1)})^T \delta^{(l+1)}) \odot \phi'(z^{(l)})$，直到输入层。之后，权重梯度$\frac{\partial E}{\partial W^{(l)}} = \delta^{(l+1)} (a^{(l)})^T$，偏置梯度为$\delta^{(l+1)}$。理解这公式推导过程，明确梯度传播关系，对复杂网络的训练很关键。
* **梯度下降更新**：有了梯度，就可以按照$\theta := \theta - \alpha \frac{\partial E}{\partial \theta}$更新参数。参数包括所有层的权重和偏置。训练中通常使用**批量梯度下降**或更常用的**随机梯度下降**(SGD)（每次使用部分样本更新）来加快收敛。现代训练还使用各种改进算法如Momentum、RMSProp、Adam等，它们在基本梯度下降基础上对梯度历史做平滑或缩放，实现更快收敛。这些优化算法虽不要求详细推导，但要知道其存在及效果。
* **正则化技术**：为推导方便这里也算重点公式：L2正则化通过在损失中加入$\frac{\lambda}{2}\sum_{weights}w^2$项，其梯度使更新公式多出$-\lambda w$项，相当于每次按比例衰减权重。L1正则化梯度为$-\lambda \operatorname{sign}(w)$使一些权重更新到0，实现特征选择。Dropout在训练中随机将一部分神经元输出置零，等效于训练不同子网络求平均，没有显式公式但概念要掌握。

### 典型例题与解法简要归纳

* **示例1：简单两层感知机分类**：如用一个隐藏层的神经网络实现异或（XOR）分类。理论上只需2个隐藏节点就可完成：隐藏层分别学习$x_1$和$x_2$的判别，再组合输出。这道题可以让学生设计网络结构，手工设置权重实现XOR。例如隐藏层计算$h_1 = \mathbf{1}(x_1 + x_2 > 1)$, $h_2 = \mathbf{1}(x_1 + x_2 < 1)$（即两个对角），输出层$y = \mathbf{1}(h_1 \vee h_2)$实现XOR。这展示了多层网络能表示非线性函数。解题时若不会精确权重，可通过逻辑说明达到异或功能即可，重点在理解网络比单层感知机强。
* **示例2：反向传播手算**：给出一个小网络（比如2输入-2隐-1出），以及一个具体训练样本，要求计算一次前向传播和反向传播更新。此类题需按步骤：①前向算隐藏层激活$h$, 输出$\hat{y}$；②算输出误差$\delta^{out}$；③反传算隐藏层误差$\delta^h$；④算出各权重梯度；⑤给出更新后的权重值。这是繁琐但经典的反向传播练习，考试中可能出现简化版，例如仅计算输出层梯度或判断给定梯度公式是否正确等。
* **示例3：激活函数比较**：可能以问答形式出现：如给Sigmoid神经元和ReLU神经元画出函数曲线并比较优劣。Sigmoid曲线S形在0附近有梯度，在极端处梯度接近0，容易梯度消失，且输出非零均值会引入偏移；ReLU在正区梯度=1，负区梯度=0，计算简单，收敛快但可能导致“神经元死去”（一直输出0）。针对这些优缺点的比较也是常考点之一，此例可要求学生简述何种情形用何激活函数，例如分类输出层用Softmax等。

### 易混淆点与常见错误

* **梯度传播误解**：反向传播是较难部分，易错在链式求导。常见误区：把隐藏层误差$\delta^h$错以为是误差对激活值$a$的偏导，其实$\delta^h_i = \frac{\partial E}{\partial z_i}$包括了后面层的影响。要记住“后一层误差乘以当前层激活函数导数再乘以权重transpose”这个模式。如果被要求推导某层梯度，不要只考虑该层局部，还要乘上后面传来的误差。
* **激活函数选择**：有人会混用激活函数，比如输出层用错激活导致结果不合理。要避免如回归问题输出层仍用Sigmoid（把结果压0-1区间）或分类隐藏层用Softmax之类。正确做法：**隐藏层**常用ReLU/tanh等，**分类输出**：二分类用Sigmoid+交叉熵，多分类用Softmax+交叉熵，**回归输出**用线性激活+MSE。答题时若问到，应能指出不同任务采用的激活配置。
* **过拟合与正则化**：神经网络参数众多，非常容易过拟合。学生有时忽略这一点。应注意回答提升泛化性能的方法，如L2正则限制权重大小、Dropout随机失活防止互适应、Early Stopping通过验证集监控提早停止训练等。如果题目问“如何防止神经网络过拟合”，切忌空泛回答“减少学习率”之类，而应给出以上切实可行的办法。
* **深度与梯度消失**：随着网络加深，容易出现梯度消失/爆炸问题。有的同学可能搞不清原因就在于链式求导连乘多个<1的Jacobian。可简单说明Sigmoid多层相乘梯度趋0，导致深层学习困难。应提及解决方案如使用ReLU类激活减轻消失、对深层网络采用批归一化(Batch Norm)和残差连接(ResNet)等，这些概念如出现在课程里可简要说明。
* **生物神经类比局限**：虽然称为“神经”网络，但不要机械套用生物神经概念误答。比如有人以为信号**通过**权重而非相乘，或误认为一个神经元可以有逻辑回路。实际上人工神经元只是粗略模拟。回答中可借鉴生物术语（如“激活”“抑制”），但一定要准确表述ANN的数学机制而非生物现象。

### 期末考试高频考点与建议记忆点

* **反向传播算法**：这是重点难点，常以计算题或原理问答出现。需记牢**误差反传公式**：输出层$\delta^L = (y - t)\odot \phi'(z^L)$，隐藏层$\delta^l = (W^{l+1^T}\delta^{l+1}) \odot \phi'(z^l)$，权重梯度$= \delta^{l+1}(a^l)^T$。能写出或解释这些公式是高分关键，可在草稿纸推导几遍加强记忆。
* **经典网络结构**：如需记忆一种最简单的多层网络结构（2-3层），以及**感知机**（无隐藏层）的定义区别。在考题中可能要求画图或解释“感知机与多层网络的差异”，应答：感知机是线性模型，多层网络通过隐藏层实现非线性决策；感知机对应逻辑回归的硬限幅激活，多层网络使用连续激活可用梯度训练等等。
* **激活函数性质**：Sigmoid/tanh/ReLU的**曲线形状**和**优缺点**要熟悉。这在选择题或判断题中常出现，例如“ReLU 会导致神经元死亡的说法正确吗（正确）”、“tanh输出均值为0有何优点（收敛更快）”等。准备时可列张表格总结：Sigmoid输出(0,1)，易梯度消失用于输出层概率；tanh输出(-1,1)，零均值梯度相对大；ReLU计算简便梯度不饱和但输出非定界。
* **参数规模计算**：有时会出简单题让算一个网络的参数总数。例如“输入10维，隐藏层5个节点，输出3类，问参数多少（含偏置）？” 答案=输入层权重$10\times5$+隐藏层偏置$5$+隐藏到输出权重$5\times3$+输出偏置$3$=总参数。这类计算不难但常考，记得权重矩阵维度=上一层节点数×本层节点数，偏置=本层节点数。
* **应用场景**：可能出现选择或简答：“为什么说神经网络是通用逼近器？”、“神经网络适合什么任务？”要回答：NN适合大数据复杂非线性问题（如图像识别、语音识别），因为其高表达能力；通用逼近指理论上1隐藏层足够多神经元可以逼近任意函数。但训练难度大，需要足够数据和正则避免过拟合。这些结论来自课程讨论，可酌情引用。

## 深度学习基础（Deep Learning Basics）

### 核心概念和定义

* **深度学习概念**：深度学习指拥有多层（深层）结构的神经网络模型的训练与应用。“深度”体现在模型具有多级非线性特征转换，每一层提取输入的更抽象表示。如图像识别中，浅层可能学到边缘等低级特征，深层能组合成人脸等高级特征。通过端到端的层级特征学习，深度学习模型在大数据上可以自动学习复杂任务的表示和决策。
* **卷积神经网络(CNN)**：一种专为处理图像等网格数据的深度网络。CNN利用**局部连接**和**权值共享**的结构特点来提取局部模式并降低参数量。卷积层的每个神经元只连接上一层相邻像素区域（称为感受野），并在不同位置使用相同卷积核（共享权重）提取特征。通过卷积层和**池化层**（如最大池化、平均池化）交替，CNN能够有效捕获平移不变的图像特征，极大提高识别图像的效果。
* **循环神经网络(RNN)**：一种用于处理序列数据的深度模型。RNN具有**时序循环结构**：隐含状态$h_t$不仅取决于当前输入$x_t$，也取决于前一时刻的状态$h_{t-1}$。这种设计赋予RNN“记忆”功能，能捕捉序列前后依赖。基本RNN容易出现梯度消失，实际常用改进如**长短期记忆(LSTM)**和**门控循环单元(GRU)**，它们通过“门”机制控制信息记忆与遗忘，缓解长期依赖训练困难。RNN及其变种在自然语言处理、时间序列预测等领域表现突出。
* **深度生成模型**：深度学习除用于判别（分类回归），还能学习数据分布进行生成。典型模型如**变分自编码器(VAE)**和**生成对抗网络(GAN)**。VAE通过编码器将数据映射到潜在空间并匹配高斯分布，再通过解码器生成数据，可用于图像/文本生成、缺失值填补等；GAN包含生成器和判别器对抗训练，能学会生成逼真的新样本。生成模型体现了深度网络对复杂高维分布的刻画能力，是当前研究热点，但训练较难、需要细致调参。
* **深度学习框架**：深度学习的成功离不开计算力和工具。常用框架如TensorFlow、PyTorch等提供自动求导和GPU加速，方便构建和训练深度网络。利用这些框架，研究者和工程师可以快速实验不同网络结构（如残差网络、注意力机制等）并在大型数据集上训练模型。深度学习在计算机视觉、语音识别、自然语言处理等众多AI领域取得突破，核心原因在于**海量数据**和**大模型**结合高性能计算所释放的潜力。

### 重点公式推导

* **卷积运算公式**：CNN卷积层的计算可表示为：$(I * K)(u,v) = \sum_{i}\sum_{j} I(u+i, v+j)\, K(i,j)$，即滤波器核$K$在输入特征图$I$上滑动，计算元素乘积和作为输出。需理解卷积是线性运算，可看作特殊的权重连接，其中$K$里的参数被重复用于整个输入平面（权值共享）。池化则是取区域内的统计量，如最大池化$P(u,v) = \max_{i,j} I(u+i, v+j)$，没有可学习参数。
* **Batch Normalization**：深度网络常用批规范化层，其公式：对于每层激活$a^{(l)}$，计算批均值$\mu_B = \frac{1}{m}\sum_{i=1}^m a_i$和方差$\sigma_B^2 = \frac{1}{m}\sum (a_i-\mu_B)^2$，然后规范化$\hat{a}_i = \frac{a_i - \mu_B}{\sqrt{\sigma_B^2+\epsilon}}$，再线性变换$\tilde{a}_i = \gamma \hat{a}_i + \beta$。BN层保持每层输入分布稳定，加快训练并有正则化效果。虽然推导不复杂，但需要记住其作用及训练/推理时不同处理（训练用批统计，推理用移动平均统计）。
* **残差连接**：ResNet提出的**跳跃连接**可以用公式描述为：$y^{(l+2)} = f^{(l+2)}(y^{(l+1)}) + y^{(l)}$，即跨过一层或几层把输入直接加到输出上。这可视为把网络拟合残差$F = y^{(l+2)} - y^{(l)}$。残差连接缓解了深层网络梯度消失并使信息流更通畅，公式上梯度可以绕过中间层直接传回，提高了极深网络的可训练性。考试可能不要求写出公式，但要能解释残差结构对梯度的影响。
* **LSTM门控单元**：LSTM内部有遗忘门 $f_t = \sigma(W_f \cdot [h_{t-1}, x_t])$，输入门 $i_t = \sigma(W_i \cdot [h_{t-1}, x_t])$，输出门 $o_t = \sigma(W_o \cdot [h_{t-1}, x_t])$，候选记忆 $C_t = \tanh(W_c \cdot [h_{t-1}, x_t])$，隐藏状态 $h_t = o_t \odot \tanh(C_t)$。虽然LSTM公式较复杂，但关键是要说明这些门控如何控制信息流（遗忘门控制保留过去记忆多少，输入门控制当前信息写入多少，输出门控制输出多少记忆）。一般不会让学生默写公式，但理解每个门的作用和上述核心计算在序列中的角色很重要。记忆状态更新 $C_t = f_t \odot C_{t-1} + i_t \odot \tilde{C}_t$。
* **梯度消失/爆炸分析**：对深度网络，链式法则表明梯度是各层Jacobian乘积，容易指数衰减或增长。定量分析如：假设每层梯度期望乘上常数$\lambda$，则$L$层网络梯度期望$\lambda^L$。当$\lambda<1$，$L$大时梯度趋0——**梯度消失**；$\lambda>1$则梯度值暴涨——**梯度爆炸**。为应对消失，采用ReLU($\lambda \approx 1$保持梯度)、残差连接（梯度有快捷路径不全依赖$\lambda^L$）等。当回答关于深层训练困难时，可用这个分析定性解释并引出解决方法。

### 典型例题与解法简要归纳

* **示例1：CNN层计算**：给一简单卷积实例：如输入3x3图像矩阵，卷积核大小2x2，stride=1，无填充，要求计算卷积输出。解题：滑动卷积核计算每个位置的加权和。要正确列出例如输出位置(1,1) = 输入(1,1..2,2)元素与核对应元素乘积和，如 $Out_{1,1} = I_{1,1}K_{1,1} + I_{1,2}K_{1,2} + I_{2,1}K_{2,1} + I_{2,2}K_{2,2}$。此题考查对卷积操作的理解，也可能让画出连接关系图（展示局部感受野和共享权重）。
* **示例2：RNN展开与计算**：给定一个小RNN，隐藏状态维度1（参数简单），输入序列长度T=3，要求手工计算前向输出和隐藏状态。如已给出$h_0=0$，权重$U, W, V$等具体值，让算出$h_1, h_2, h_3$和对应输出$y_1, y_2, y_3$。解题关键：按时间步迭代使用 $h_t = \tanh(U x_t + W h_{t-1})$，$y_t = V h_t$（假设线性输出或加softmax看题意），一步步代入计算。这考核对RNN“时间展开”后的计算流程理解。
* **示例3：GAN原理问答**：可能出现概念题询问GAN如何训练。回答应包含：GAN包括生成器G和判别器D，D学习判别真伪，G生成数据骗过D；训练时交替优化，D最大化判别准确率，G最小化被D识破概率（即最大化$\log D(G(z))$）；经过博弈，两者达到纳什平衡，G能产出以假乱真的样本。此例检查对当代深度学习热点的理解，要求能简述原理而非细节证明。
* **示例4：深度学习应用**：给一个场景让选模型并说明理由。如“设计一个系统识别人脸中的情绪，用深度学习方法，你会选择什么网络结构？”合理答案：使用CNN提取人脸图像特征，然后用Softmax分类表情，因为图像任务CNN表现最好，并可通过预训练模型（如VGG/ResNet）微调。这个例子不是计算题而是考查对不同深度模型擅长任务的认识，回答中应体现选择的模型及简要原理。

### 易混淆点与常见错误

* **卷积与全连接区别**：初学者易混淆卷积层和全连接层的连接方式。要清楚卷积是局部连接+参数共享，参数量与核大小无关输入大小，而全连接层每个神经元连遍所有输入。若问到两者优缺点，需答：卷积对位置信息不敏感（平移不变），参数远少于全连接，适合图像；但全连接更通用，不需要结构化输入。不要笼统回答“卷积就是矩阵相乘”，应强调空间局部性。
* **RNN梯度消失**：RNN因重复乘相同权矩阵，梯度消失更严重。有同学认为LSTM完全解决了消失问题，其实只是缓解。答题涉及“为什么LSTM好于RNN”时，可说因为LSTM引入门控使梯度在时间上直接传递（C状态线性累加记忆），相比简单RNN更不易梯度消失。但也要指出长序列LSTM仍会有困难，只是能记得较长信息。不能答成“LSTM没有梯度消失”，那是不准确的。
* **训练时间和硬件**：深度模型通常训练时间长，需要GPU。可能有人忽视计算限制提出不切实际方案。若考题问“某任务为何现阶段深度学习无法胜任”，答案可能包括**数据缺乏**或**计算资源不足**。不要只夸DL好处，也要知其局限：需要大量标注数据和强算力。比如小数据任务深度学习易过拟合传统方法更佳，这在论述题可作为加分点。
* **黑盒性质**：深度模型难以解释，一些回答可能声称深度学习提供清晰可解释规则，这是错误的。正确认识：深度模型准确率高但可解释性差，是活跃研究方向。如果论到这点，要承认问题并提及一些可解释AI的方向，如可视化卷积层特征或对Attention机制的解释等，但不要硬说深度模型容易解释。
* **新模型炒概念**：深度学习领域术语多，例如Transformer、注意力机制等。如果课程未涉及，不要生搬硬套写不懂的buzzwords。若涉及也需解释简要原理，如“注意力机制通过加权聚合序列信息，突出相关部分”。切忌只写流行词汇却没有说明原理，这会让阅卷人觉得概念不清。回答保持课程覆盖范围内为宜。

### 期末考试高频考点与建议记忆点

* **CNN结构特点**：务必记住卷积神经网络的两个关键特性：局部感受野和权重共享。考试喜欢问“卷积层如何减少参数”或“卷积网络为何擅长图像处理”，回答就围绕这两点展开。另外池化层作用（降维、平移不变）也应掌握。把这些关键词和含义熟记于心。
* **典型网络名称**：深度学习涌现很多经典网络，课程中若提到，要记下名称和用途。如**LeNet**（首个卷积网络用于手写数字识别），**AlexNet**（深度学习崛起标志，ImageNet冠军），**ResNet**（残差网络，152层解决梯度问题），**Transformer**（基于注意力的序列模型，非RNN结构）。考试可能不深究细节，但会要求辨识这些名字及对应创新。例如选择题：“以下哪个网络通过引入残差连接训练超深模型？（ResNet）”。
* **前沿概念理解**：课程后段如提及GAN、强化学习等新方向，考试一般考质朴概念。如“GAN如何训练”“强化学习和监督学习的区别”。记忆时注重理解：GAN是生成模型，两网络博弈训练；强化学习通过奖励信号学习策略，不需要监督标签等。不会让写公式但要能区分这些学习范式和应用场景。
* **深度学习成功原因**：有时作为简答题考查对大局的认识，可从**数据**（大数据提供燃料）、**算力**（GPU并行计算）、**算法**（更深结构、激活函数和优化改进）三个方面回答。特别是提出“深度”优势：层数加深自动特征学习代替人工特征设计等。这些论点在复习时应有所准备，以免考场上思路空白。
* **常见问题及对策**：深度学习常见训练问题如过拟合、梯度消失、训练慢等要知道对策。过拟合对策：正则化、更多数据、数据增强、Dropout等；梯度消失：ReLU/残差/梯度剪裁/预训练初始化等；训练慢：用批归一化调节分布、Learning rate调度等。这类内容可能在考试中以问答形式出现，回答时措施要针对问题，一一对应。

## 贝叶斯分类（Bayesian Classification）

### 核心概念和定义

* **贝叶斯决策理论**：基于**贝叶斯定理**利用后验概率进行最优决策。贝叶斯定理：$P(Y|X) = \frac{P(X|Y)\,P(Y)}{P(X)}$，其中$P(X|Y)$是似然，$P(Y)$是先验。对于分类问题，贝叶斯分类器将样本分到使后验概率$P(Y=k|X=x)$最大的类别$k$。这种策略在错误代价相同且先验准确已知情况下可证明是最小错误率决策（即**贝叶斯最优分类器**）。
* **朴素贝叶斯分类器**：由于直接计算高维$P(X|Y)$困难，**朴素贝叶斯(NB)**引入**条件独立假设**：假设给定类别$Y$，各特征$X_i$彼此独立。于是后验概率可近似为：$P(Y|x_1,\dots,x_n) \propto P(Y)\prod_{i=1}^n P(x_i|Y)$。分类时计算各类这一值，取最大者判定类别。朴素贝叶斯虽然独立假设简化很强（通常不成立），但在很多实际场景（尤其文本分类等）表现尚可，因其估计所需参数少、对小数据也较稳健。
* **先验与后验**：**先验概率**$P(Y)$反映类别的先验流行程度，比如垃圾短信分类中垃圾短信的先验概率可能较小。**后验概率**$P(Y|X)$综合了先验和证据（似然）得出给定观测属于该类的概率。贝叶斯分类强调融合先验知识进行决策，比如在医疗诊断中疾病罕见（先验低）即使检测阳性也可能总体概率不高，这正是贝叶斯定理的作用。若无明确先验，可假设各类先验相等，再靠似然区别。
* **参数估计**：朴素贝叶斯需要估计$P(x_i|Y)$和$P(Y)$。对于**离散特征**，通常通过**频率估计**得到条件概率表，加入拉普拉斯平滑避免概率为0的情况（每种情况计数加1)；对于**连续特征**，常假设服从某分布如高斯分布（即**高斯朴素贝叶斯**），通过计算各类下特征均值和方差确定$P(x|Y)$密度函数。考试中可能要写出这两种估计的方法，如离散型公式$\hat{P}(X=v|Y=k) = \frac{\text{count}(X=v,Y=k)+1}{\text{count}(Y=k)+|\mathcal{X}|}$（加1平滑）等。
* **应用**：朴素贝叶斯广泛用于文本分类（如垃圾邮件过滤、新闻分类），因文本高维且特征（词语）独立假设虽不严格但在统计上有效，且NB模型训练预测都极快。也用于医疗诊断、故障检测等需要结合先验知识的领域。NB模型易受违背独立假设影响，相关特征较多时性能会下降，但在特征条件独立近似满足时具有很强竞争力。

### 重点公式推导

* **贝叶斯定理公式**：$P(Y=k|X=x) = \frac{P(X=x|Y=k)P(Y=k)}{\sum_{j}P(X=x|Y=j)P(Y=j)}$。推导注意分母是对所有类别的全概率，通常求最大后验时分母相同可省略，只比**分子**大小。可解释为“后验=似然×先验/规范化常数”。考试若问贝叶斯定理，这个公式必须熟练写出并指明各项含义。
* **独立假设公式**：若$X=(X_1,...,X_n)$特征独立，$P(X|Y) = \prod_{i=1}^n P(X_i|Y)$。代入贝叶斯定理得朴素贝叶斯决策依据：$\hat{y} = \arg\max_{k} P(Y=k)\prod_{i=1}^n P(x_i|Y=k)$。这公式是朴素贝叶斯分类的核心，应牢记。在阐述独立假设时要强调这是近似，并非由贝叶斯定理严格推导，而是一种建模假设以简化计算。
* **零概率与拉普拉斯校正**：若训练集中某特征值在某类没出现，则频率估计会给 $P(x_i = v \mid Y = k) = 0$，从而后验为 0 导致过分自信的错误。**拉普拉斯平滑**解决办法是给计数加上一个常数（通常为 1）。

$$
P(X = v \mid Y = k) = \frac{N_{vk} + 1}{N_k + |\mathcal{X}_i|}
$$

其中 $N_{vk}$ 表示类别 $k$ 中特征 $i$ 取值 $v$ 出现次数，$N_k$ 是类别 $k$ 的样本数，$|\mathcal{X}_i|$ 是特征 $i$ 可能取值数。推导拉普拉斯校正结果等价于使用先验为均匀分布的贝叶斯估计结果。理解这个推导有助于解释为何平滑能改善模型鲁棒性。
* **连续特征概率密度**：高斯朴素贝叶斯假设特征对每类服从正态分布$P(X_i=x|Y=k) = \frac{1}{\sqrt{2\pi}\sigma_{ik}}\exp{-\frac{(x-\mu_{ik})^2}{2\sigma_{ik}^2}}$。训练时根据类内样本计算均值$\mu_{ik}$和标准差$\sigma_{ik}$。带入后验公式仍按乘积求解。尽管公式简单，但要注意密度不再是概率，需要比较的是$P(Y=k)\prod_i \frac{1}{\sigma_{ik}}\exp{-\frac{(x-\mu_{ik})^2}{2\sigma_{ik}^2}}$。考试可能要写出高斯NB模型假设和参数估计公式。
* **判别函数形式**：朴素贝叶斯也可改写成线性判别函数形式。对数后验$\ln P(Y=k|X) = \ln P(Y=k) + \sum_i \ln P(x_i|Y=k) + \text{const}$。对于离散特征，这相当于给每个特征值赋一个权重（即$\ln P(x_i=v|Y=k)$），先验则是偏置。这说明朴素贝叶斯对应于输入为one-hot编码时的线性分类器，但参数由统计频率得到而非通过优化学得。这种推导在西瓜书等教材中提及，若题目深入可简要提及帮助理解NB与逻辑回归的联系。

### 典型例题与解法简要归纳

* **示例1：天气数据朴素贝叶斯**：经典天气打球数据（Outlook、Temperature等特征，Play网球=Yes/No）。可能要求用朴素贝叶斯分类器计算某一组合$(x_1,...,x_n)$下Yes和No的后验概率，并判断类别。如计算$P(\text{Yes}|X)$和$P(\text{No}|X)$比例。解题步骤：先根据训练集计算先验$P(\text{Yes}),P(\text{No})$和各条件概率如$P(\text{Outlook=Sunny}|\text{Yes})$等。然后代入独立假设公式算后验比值，比较大小。需要注意平滑问题（若遇到0概率要说明按0处理还是假定没有0出现）。这个练习考核能否正确应用贝叶斯公式和独立假设。
* **示例2：简单邮件分类**：给定两类（垃圾邮件/正常邮件）的一些词频统计数据，如在垃圾邮件中“优惠”出现次数、正常邮件中出现次数，等等，然后给一封新邮件的词出现情况，让用NB判断。解题思路：计算每个类别的先验（通常垃圾邮件比例）、计算给定邮件的各词在两类下的条件概率乘积。若使用多项式模型，还需词频的条件概率（包括Laplace平滑）。算出两个后验，判断较大者为结果。这类题贴近实际应用，重点在正确乘积各词概率并乘先验。
* **示例3：连续值贝叶斯分类**：如根据肿瘤尺寸预测良恶性，用高斯NB。训练数据给出两类下尺寸的均值方差，让算某个新肿瘤尺寸下后验。步骤：算各类先验$P(Y)$，计算似然$P(\text{size}=x|\text{恶性})$和$P(x|\text{良性})$通过正态公式，再用贝叶斯定理求后验比值。如果问及模型假设，要回答模型假定尺寸在每类服从正态，并引用所用均值方差。解题时易错在比较大小可以不算归一化常数，只比较分子即可。
* **示例4：独立假设反例**：或许会出理论题指出两个特征明显相关，问朴素贝叶斯有什么问题。答：NB假设它们独立，实际上不独立会导致计算的后验概率偏离真实。有时会引导学生考虑，比如两个特征完全相同冗余，则NB会重复计算其证据，使后验过于偏向某类。可以用具体概率数字说明这种双重计算导致的问题（即NB问题），并指出尽管独立假设不成立NB仍可能在分类上有不错效果，因为决策只需后验最大类别，不要求概率绝对准确。

### 易混淆点与常见错误

* **条件独立误解**：不少人会误以为朴素贝叶斯需要特征完全独立才能用。实际上，尽管独立假设往往不成立，但NB仍可用于分类，只是后验计算是近似的。特别是当各类别特征相关程度相近时，NB决策仍是可靠的。要避免回答“特征不独立NB就不能用”，而应该说“不独立会影响概率估计，但NB分类决策有时仍健壮”。
* **先验忽略**：在计算后验时，忘记乘以先验$P(Y)$是常见错误。先验在样本不均衡时非常重要。答题若碰到类别比例不同，一定要乘先验体现出区分。如垃圾邮件例子，垃圾邮件先验小，不考虑先验会倾向误报垃圾。另一个误区是用不正确的先验，如明明数据集中各类比例就该作为先验，却想当然设为0.5。这都要注意避免。
* **拉普拉斯平滑漏用**：遇到某类别下从未出现的特征值，如果不加平滑会导致该类别后验为0。学生有时在计算中直接给0导致判断失误。应该意识到要**加1平滑**，哪怕题目未明示，也应主动说明避免零概率。如果考试出现某类样本数很少或有未出现值，最好写一句“采用拉普拉斯校正以防零概率”来表明意识到了这个问题。
* **概率解释错误**：贝叶斯分类输出的后验概率并非绝对可靠的概率（尤其在独立假设不成立时偏离实际概率），只是用于比较大小决策。有人可能把朴素贝叶斯输出直接解读为概率值然后阐述过多意义，这是不严谨的。应当明确NB的数值主要用于**比较**不同类哪个大，而不要断言“模型输出90%概率就是有90%把握”，因为那90%可能并不真实。如果问及后验值意义，可说是“在模型假设下计算的相对可能性”。
* **判别模型混淆**：朴素贝叶斯是生成模型，学生可能与判别模型（如逻辑回归）搞混。需避免将逻辑回归的思想套到NB上，比如以为NB参数是通过梯度优化学得，其实NB参数来自数据频数估计。若考题问两者区别，要答：NB利用$P(X|Y)$和$P(Y)$进行建模，有独立假设，而逻辑回归直接学习$P(Y|X)$，对特征无独立假设，是判别式，通常在独立假设不满足时表现更佳。

### 期末考试高频考点与建议记忆点

* **贝叶斯定理及朴素假设**：要非常熟练写出贝叶斯公式并阐释各项意义，这是基础中的基础。朴素贝叶斯的条件独立假设也应张口即来。通常选择题会有用文字描述贝叶斯公式或独立假设的正确选项，理解这些概念才能选对。
* **朴素贝叶斯推导**：考试喜欢考“根据贝叶斯定理推导朴素贝叶斯公式”的问答。这要求从$P(Y|X)\propto P(X|Y)P(Y)$开始，代入独立假设推出$P(Y=k|X) \propto P(Y=k)\prod_i P(x_i|Y=k)$，这一推导要表述清楚，并强调“由于假设特征条件独立”。建议预先演练书写这个推导。
* **概率计算题**：一定准备好应对NB概率计算的小题。例如刚才的天气或邮件例。练习时确保自己不会因为计算繁琐出错，明确哪怕不算分母，也要写清楚比较哪个更大。常见考法：给小数据表，问“用朴素贝叶斯计算某样本属于类A和B的后验概率各是多少？应判为哪类？”。按部就班列公式、代数字、出结果，这方面要细心。
* **平滑与问题**：出题老师常考查对朴素贝叶斯局限的认识，如“朴素贝叶斯有何缺点？如何改进？”。应答独立假设过强、输出概率未经校准等，改进可提**半朴素贝叶斯**（考虑部分依赖，如TAN树增强）、**贝叶斯网络**（一般化的概率图模型）或者简单地“引入相关特征会降低准确率”。另一个缺点：如果一个条件概率为0会使结果为0，需要用平滑处理。这都属于NB模型需要了解的问题点。
* **NB vs 逻辑回归**：高频考点，需掌握结论：当独立假设真实时，朴素贝叶斯是条件概率的正确计算器，此时NB表现好；当独立假设不成立但模型仍强假设独立，逻辑回归这种判别模型更能学习到特征相关的判别边界。也要知道NB对小数据更稳健，因为有先验和统计频率平滑，逻辑回归小数据容易过拟合。这些比较可以帮忙回答开放题，也可能以判断题形式出现。

## 集成学习（Ensemble Learning）

### 核心概念和定义

* **集成思想**：集成学习通过组合多个分类器/回归器（基学习器）的预测来提高整体性能。其理论基础是“**多数表决胜任意**”（many heads are better than one）：只要各基学习器有一定准确率且彼此**误差多样化**，通过适当策略组合（如投票、加权平均），集成结果往往比单一模型更准确、更稳定。集成能够降低模型方差、抵抗过拟合，同时保持偏差不至于太高，是实践中提升算法效果的有力方法。
* **Bagging(套袋法)**：一种并行式集成方法，通过对训练集进行**自助采样(bootstrap)**来训练多个基模型，再对结果平均。每个基学习器都在从原始数据随机放回采样得到的子集上训练。各模型独立训练，互相不影响。最终分类通过**多数票**表决，回归取平均。Bagging通过数据扰动制造多样性，能显著降低模型方差，代表方法是**随机森林**（多棵决策树Bagging且随机选特征）。
* **Boosting(提升法)**：一种串行式集成方法，序列地训练基学习器，每轮侧重**纠正前一轮错误**。常用实现是AdaBoost：初始赋予每个样本相等权重，训练一个弱分类器后，增加误分类样本权重、降低正确分类样本权重，然后用调整后的样本权重分布训练下一个模型。如此迭代，使后来的模型更关注前面模型未处理好的样本。最终将所有弱分类器按其精度加权投票。Boosting能显著降低偏差，但也可能提高方差，要注意避免过拟合。经典算法有**AdaBoost**、**Gradient Boosting**（如GBDT）。
* **Stacking(堆叠法)**：一种混合集成方法，用**元学习**器来学习如何组合多个不同类型的基学习器。一般流程：训练初级学习器（如逻辑回归、决策树、SVM等）得到预测，然后以这些预测作为新的特征，再用次级学习器（如线性模型）学习最佳融合。Stacking不局限于同质模型，可将不同优势的模型结合。它通过学习器自动调融合权重，常比简单投票性能更好。但训练较复杂，需注意防止信息泄露（通常用交叉验证预测作为次级输入）。
* **集成多样性**：集成效果取决于基学习器的差异度和准确度。多样性越高，模型误差相关性越低，集成收益越大。实现多样性的方法有：数据采样差异（Bagging随机抽样每个模型训练集不同）、模型参数差异（初始权重不同的神经网络）、模型种类差异（组合决策树、SVM、KNN等）。同时每个模型准确率要比随机好。集成学习致力于平衡“准确又多样”的基模型集合，保证最终投票相互弥补错误，提升总体准确率。

### 重点公式推导

* **Bagging错误率公式**：若每个基分类器错误率为$\epsilon$，任意两个分类器错误独立，则$T$个分类器多数投票错误率 $=\sum_{k=\lfloor T/2 \rfloor+1}^T \binom{T}{k} \epsilon^k (1-\epsilon)^{T-k}$。随$T$增大，该错误率快速下降趋近0（若$\epsilon<0.5$）。虽然独立假设不严格，但公式表明：基分类器越多且独立效果越好，集成越强。这一推导解释了Bagging降低方差的原理。考试一般不要求手算此公式，但可用于论证集成优势时引用。
* **AdaBoost权重更新公式**：给定第$m$轮弱分类器错误率$e_m = \Pr_{i\sim D_m}[h_m(x_i)\neq y_i]$（按当前分布$D_m$），弱分类器权重$\alpha_m = \frac{1}{2}\ln\frac{1-e_m}{e_m}$。样本权重更新：$D_{m+1}(i) = \frac{D_m(i)\exp(-\alpha_m y_i h_m(x_i))}{Z_m}$，其中$Z_m$是归一化因子。正确分类样本由于$y=h_m(x)$，指数因子$\exp(-\alpha_m)$<1，权重降低；反之错误分类样本权重提高。这两式是AdaBoost核心公式，应熟记。如果考试问AdaBoost过程，要写出或说明$\alpha_m$计算和权重更新规律。
* **梯度提升(GBDT)**：GBDT将提升思想推广到回归树，用梯度下降观点解释。每轮$m$训练一个回归树$h_m(x)$来近似残差（即前序模型对负梯度方向的最优下降），然后以学习率$\eta$缩小步长更新累积模型$F_m(x) = F_{m-1}(x) + \eta h_m(x)$。推导上，把损失$L$对预测的负梯度 $-g_i^{(m)} = -\left[\frac{\partial L(y_i, F(x_i))}{\partial F(x_i)}\right]$ 作为新目标值拟合，能证明$F_m$沿梯度方向下降损失最快。虽然公式复杂，理解这梯度下降框架即可。如果考到GBDT，应指出它每轮拟合前一轮残差（梯度），是Boosting的泛化版本。
* **随机森林随机性**：随机森林是Bagging改进版，不仅对样本采样，对特征也采样。即每棵树在每次节点划分时，从全特征集合随机选取一个子集再选择最佳分割特征。这样确保树与树之间差异更大。没有具体公式但要理解随机森林**每棵树看到的特征空间不同**，降低了树之间相关性。若问随机森林与一般Bagging区别，要答出这一点和它如何提升多样性。
* **误差分解**：集成减少方差的原理可通过偏差-方差分解说明：集成模型的期望偏差和单模型相当，但方差被平均$T$倍（如完全独立情况下）。简化公式：$\text{Var}(\frac{1}{T}\sum f_i) = \frac{1}{T^2}\sum \text{Var}(f_i) = \frac{1}{T}\text{Var}(f)$（假定独立等分布）。这个1/T关系是关键。考试可能让解释Bagging降低过拟合，可从方差减小角度说明这一公式结论。

### 典型例题与解法简要归纳

* **示例1：人工示例Bagging**：给出一个小数据集，要求手工演示Bagging抽样和模型训练过程。如数据只有5个点，用自助法抽样3次（每次5个点有放回采样）得到3个不同训练集，然后训练3个决策树，最后综合投票分类某个新点。这检查是否理解bootstrap采样会重复某些样本遗漏某些样本（平均留出约36.8%所谓袋外样本），以及最终如何投票。解题要列出每个采样集内容，假设各树结果，再给投票结果。
* **示例2：AdaBoost计算**：给出一组简单数据（如一维可分数据点，画在数轴上），要求执行两轮AdaBoost弱分类器训练。弱分类器可选简单阈值分类器。解答步骤：初始每点权重均等；第1轮找到最优阈值分类器及错误率$e_1$，算$\alpha_1$，更新各点权重；第2轮在新权重下重复。最后组合两个弱分类器。这个过程繁琐但经常考，让学生体会Boosting如何聚焦难分类样本。要小心计算权重归一化$Z_m$，同时能说出最终集成分类函数$H(x)=\operatorname{sign}(\alpha_1 h_1(x)+\alpha_2 h_2(x))$。
* **示例3：比较Bagging和Boosting**：可能出开放题“Bagging和Boosting有何异同？”。应分别说明：Bagging并行训练，靠样本扰动，降低方差，减小过拟合；Boosting串行训练，聚焦错误，降低偏差，但过拟合风险较Bagging高。异同可以从训练方式（并行vs串行）、提高效果方式（减方差vs减偏差）、基模型权重（均等vs按性能加权）等角度阐述。举例：随机森林vs AdaBoost，两者都是集成但工作原理不同。这样条理分明地比较最清晰。
* **示例4：Stacking应用**：若课程涉及Stacking，可能问如何设计一个Stacking方案。如“用Stacking融合KNN、决策树和SVM，描述训练过程”。答：先用这三模型各自10-fold CV对训练集预测，得到次级训练集特征（每折用模型在未见数据上的预测），再用次级学习器（如逻辑回归）在此训练；预测时，先用三个一阶模型得到预测作为次级输入，再经次级模型输出最终结果。这例子考查对Stacking避免过拟合的技巧（交叉验证产生次级训练数据）。抓住要点回答，不用细节实现代码，但流程要写对。

### 易混淆点与常见错误

* **基模型独立性**：Bagging理论推导假设分类器独立，但现实中同源模型常有相关误差。考生可能误认为Bagging真能把错误率降到很低甚至0，这是理想情况。要明白：实际基模型有相关性，收益低于理想。但随机森林通过特征随机选择降低了相关性。答题时若提到Bagging效果，也可指出独立假设不成立会削减收益，这表现出全面的认识。
* **Boosting过拟合**：AdaBoost经典观点是能持续降低训练误差而测试误差不一定上升，但并非不会过拟合。误区在于不设早停的Boosting最终也会过拟合（尤其在噪声数据）。所以回答Boosting优缺点时要敢于指出“Boosting偏差低但可能方差高、对噪声敏感，过拟合风险比Bagging高，需要通过限制迭代轮数等正则策略控制”。
* **多重采样理解错误**：Bagging的bootstrap采样很多人知道63%样本被采到至少一次，但容易误答成“Bagging每次用63%的数据训练”。实际上每个基模型训练集等大于原始集，只是有重复。要避免混淆“有放回抽样”和“无放回抽样”的区别。答题若谈到Out-of-Bag估计，也应说明剩下约36.8%没被采样，可用于测试，这是一种评估集成泛化性能的方法。
* **Stacking信息泄露**：Stacking若不使用CV产生次级训练，会发生模型在训练集上预测再训练次级模型，导致过拟合。这属于信息泄露。很多初学者会忽略CV这步，答题只说“把各模型预测作为新特征再训练元模型”却没提要避免直接用训练集预测。阅卷人可能扣这一点。所以如提Stacking，最好强调用独立验证方式产生一级模型预测，保障公正。
* **应用场景选择**：集成并非任何情况都适用，简单模型上过度集成收益有限。学生有时倾向“有集成一定用集成”。实际应看情况：数据复杂、模型不稳定（如决策树）时Bagging/Boosting收益大；模型已高复杂度或数据很少时，再集成可能过拟合或收益小。回答有关“是否应用集成”的题，要体现出这种分析。例如对于线性回归这种稳定模型，Bagging效果不明显，就不必集成。

### 期末考试高频考点与建议记忆点

* **三大方法特点**：Bagging、Boosting、Stacking的原理和差异几乎是必考知识点。要能快速归纳：Bagging=并行+投票平均、Boosting=串行+加权累加、Stacking=融合不同模型+次级学习。最好准备一个表格记忆，从训练方式、基模型加权、抗噪性、代表算法等角度比较。
* **AdaBoost公式**：务必熟记AdaBoost的更新公式以及弱分类器权重$\alpha_m$表达式。这经常以填空或选择出现，如“提高错分样本权重的因子是什么（exp(α)）”“弱分类器权重与错误率的关系（log((1-e)/e))”。明确每轮误差率$e_m$如何影响$\alpha_m$大小（错误率越低，$\alpha$越大权重越高）。
* **随机森林机制**：随机森林作为Bagging的著名代表，可能会问其特殊机制。要记得：除了Bagging采不同样本外，每棵树在分裂节点时随机选$\sqrt{d}$（分类任务）或$d/3$（回归任务）个特征候选，从中选最佳划分。这样每棵树更独特。由于课程材料常强调这点，考试问“随机森林如何进一步增强多样性”就答“在树节点划分时采用随机子空间法（随机选部分特征）”。如果问RF优点，也可提其抗噪声和无需剪枝、可算特征重要性等实用优点。
* **偏差-方差涉及**：集成降低方差的理论基础可从偏差-方差平衡角度考。可能让解释“为什么不完全依赖一个模型而用集成”。就用偏差-方差回答：多个模型平均可相互抵消噪声误差降低方差，而适当保持每个模型偏差不大，因此总体泛化更好。记住那个$1/T$公式结论就够用，不必推导细节，但要理解前提是假设模型独立且期望相同偏差，这也可以说来表明现实和理想差异。
* **集成代表算法**：名字要对应。Bagging代表：随机森林（Random Forest）；Boosting代表：AdaBoost, GBDT（XGBoost, LightGBM等实现）；Stacking有时叫Blending。考试可能考“下面哪个不属于Boosting算法？”之类，要能识别。例如随机森林不是Boosting；AdaBoost不是Bagging。认真回顾课程提过的具体算法名及归类，不要张冠李戴。

## 聚类（Clustering）

### 核心概念和定义

* **无监督学习**：聚类是无监督学习任务，没有标签指导，旨在根据相似性将样本自动分组。**聚类假设**：同一簇内样本彼此相似，不同簇样本差异大。通过定义样本间的距离或相似度来度量“相似”。聚类结果需要根据任务解释，每个簇可能对应某种潜在类别或概念，但算法本身不知道真实语义。
* **K均值算法**：一种常用的划分(cluster partitioning)方法，将数据划分为$K$个簇。算法迭代执行：1）**簇分配**：根据当前簇中心，把每个样本指派到最近的中心所属簇；2）**中心更新**：重新计算每个簇的质心（各维度均值）。重复上述步骤直到中心稳定或变化很小。K均值的目标函数是**簇内平方误差和(SSE)**最小，即$\sum_{k=1}^K \sum_{x_i \in C_k} |x_i - \mu_k|^2$。K均值简单高效，但要求预先给定簇数$K$，对初始值敏感，易陷局部极小。
* **层次聚类**：通过建立层次关系来聚类，有**凝聚式**(自底向上)和**分裂式**(自顶向下)两类。凝聚式(Agglomerative)开始时每样本自成一簇，不断将最相似的两簇合并，直到簇数达到期望或所有样本成一簇；分裂式(Divisive)反之，从整体开始不断细分。层次聚类结果可以用**树状图(dendrogram)**表示，不需要预先指定簇数。关键是定义**簇间距离**度量，如单链(Single-link)最小距离、全链(Complete-link)最大距离或平均距离等，不同方法得到的簇形状不同。
* **密度聚类**：基于密度的聚类认为簇是**样本密度较高**的区域。典型算法是**DBSCAN**，需要两个参数：邻域半径$\epsilon$和密度阈值MinPts。算法从任意样本出发，如果在$\epsilon$邻域内有超过MinPts个点，则以此为核心扩展形成簇，将邻域内点加入并递归检查它们的邻域，直到簇不再增长。无法归入任何簇的点视为噪声。密度聚类能够发现任意形状的簇且自动识别噪声，无需提前指定簇数，但对参数选择较敏感，高维数据表现欠佳。
* **评价指标**：无监督聚类需要内部或外部指标评估。**内部指标**利用数据本身，如**轮廓系数(Silhouette coefficient)**综合衡量每个样本与本簇的紧密度和与最近其他簇的分离度（值在-1到1，越高越好），**SSE**总和（越低簇越紧凑）。**外部指标**需真实标签，如**纯度(Purity)**、**NMI**（归一化互信息）等，比较聚类与真实分类的一致程度。考试更可能考内部指标概念或让根据SSE曲线找“肘部”确定合理簇数等。

### 重点公式推导

* **欧氏距离**：聚类常用距离度量之一，两个样本$x=(x_1,\dots,x_d)$和$y=(y_1,\dots,y_d)$的欧氏距离 $dist(x,y) = \sqrt{\sum_{j=1}^d (x_j - y_j)^2}$。它度量了样本间“直线”距离。K均值使用欧氏距离等价于最小化方差。在实现中常忽略平方根，因为距离平方相对大小相同且计算简单。需注意高维情况下欧氏距离可能失效（维度灾难），可考虑标准化或使用余弦相似度等其他度量。
* **SSE目标函数**：K均值的损失函数公式 $J = \sum_{k=1}^K \sum_{x_i \in C_k} |x_i - \mu_k|^2$。推导K均值聚类正确性的关键一步是证明每轮中心更新确实最小化了当前簇分配下的误差：质心$\mu_k = \frac{1}{|C_k|}\sum_{x_i \in C_k} x_i$能证明使$\sum_{x\in C_k}|x-\mu|^2$最小（导数为0求解得到均值）。在算法终止时，簇分配和中心均不再改变，即达到局部极小的SSE。考试或许让写出这个目标函数并解释含义。
* **层次聚类的距离**：几种簇间距离定义：单链：$d_{\min}(A,B)=\min_{x\in A,y\in B} dist(x,y)$，全链：$d_{\max}(A,B)=\max_{x\in A,y\in B} dist(x,y)$，平均链：$d_{\text{avg}}(A,B)=\frac{1}{|A||B|}\sum_{x\in A}\sum_{y\in B} dist(x,y)$。在凝聚层次聚类中，每步选最小簇间距离簇合并。单链易形成“链状”簇（长蛇形），全链倾向等距紧凑簇。这些公式需要理解但记忆两个主要的也可。可能问“单链和全链有何区别”，可用公式描述。
* **轮廓系数公式**：Silhouette系数$s_i = \frac{b_i - a_i}{\max(a_i,b_i)}$，其中$a_i$是样本$i$所在簇内平均距离，$b_i$是样本$i$到最近其他簇的平均距离。$s_i$接近1表示样本簇内距离远小于其与其他簇距离（聚类合理），接近-1表明应该归入别的簇。总体Silhouette为各$s_i$均值。考试可能不会要求写公式但会问概念，这个指标是较好的内部评价标准，值得理解。
* **肘部法确定K**：通过绘制簇数K与SSE的曲线来寻找拐点。当增加K到某值后SSE下降幅度变小，此点被称为“肘部”，对应较优的簇数选择。这个方法没有严格公式，但过程重要：观察曲线从陡降变平缓的位置。要知道肘部法的原理：K增大SSE总是减小，但收益递减明显处是合理K。可能考简答让说明如何选择K，可答用肘部法看SSE曲线或者Silhouette最大值等。

### 典型例题与解法简要归纳

* **示例1：K均值计算**：给出一组二维点和K值，要求执行一两轮K均值迭代。解法：1）初始化给出或随机中心；2）根据当前中心将每个点分配到最近中心簇；3）计算新的簇中心（各簇点坐标均值）；如果需要再迭代则重复分配->更新。考试中，数据量不会大，可手算距离和均值。关键在于正确划分簇和算均值。最好画图辅助理解哪点归哪个中心，可避免错误。
* **示例2：层次聚类过程**：给几个点距离矩阵，让执行凝聚层次聚类，画出树状图。步骤：找当前最近的两个簇合并，更新距离矩阵（根据链法规则计算新簇与其他簇距离），重复直到只有一个簇。要记录每次合并哪些簇、合并距离，对应树状图的连线高度。典型例子可能是学生分宿舍问题、或者散点距阵，一般不会超过5个点。解题时一定小心计算距离更新，不同链法不同规则，否则树图可能错。
* **示例3：DBSCAN判定核心点**：给一小数据集二维坐标图或距离矩阵，并给$\epsilon$和MinPts，问哪些点是核心点、哪些是边界/噪声，会形成几个簇。解题要计算每个点$\epsilon$邻域包含点数，>=MinPts则是核心点；再看核心点可以直达连接哪些点组成簇。检查剩下非核心非噪声的边界点附属在哪个簇。此类题考对DBSCAN概念掌握，解答可列表每点邻域包含列表和类别归属。
* **示例4：选择聚类算法**：问“某种数据分布下哪种聚类算法更适合？”比如非凸形状簇应选DBSCAN或谱聚类，因为K均值倾向球状簇；数据有噪点DBSCAN可识别噪声簇而K均值不行。或者问“层次聚类优缺点”，要提无需预设K、结果多尺度但复杂度高、难以修改错误合并等。总之，通过具体场景说明每种方法适用性和局限性，是可能的简答方向，应熟悉各算法特点来回答。

### 易混淆点与常见错误

* **局部最优**：K均值结果依赖初始值且易陷局部极小，但有些学生误以为一定能得到全局最优。应清楚说明通常跑K均值要多次随机初始化取最优结果或用K-Means++初始化改进。若问“K均值有什么问题”，一定提初始敏感和可能收敛到次优。<br>
* **K均值处理类别属性**：K均值要求均值有意义，一般用于数值型特征。如果数据有类别型特征不能直接用K均值（不能算平均）。很多人忽略这一点而生搬硬套。实际对于类别数据可用K-modes算法（用众数代替均值）。如题目涉及类别数据，要注意不能选K均值或需先数值编码再处理。
* **簇数K选择**：常见误区是总想找“正确K”，但聚类没有绝对正确K，需要根据任务或指标决定。不能说“看数据分布决定K”。要提及**领域知识**或**评估指标**。如果问“How to determine K”，最佳回答是：“使用肘部法/轮廓系数等指标，在不同K下评估聚类质量，选择性能提升不明显处作为合适K”。而不是随便说“肉眼看数据”或者“不需要K”这样不精确的话。
* **层次聚类空间复杂度**：层次聚类尤其凝聚法，距离矩阵需存储$O(n^2)$，合并更新也$O(n^2)$时间，同学有时忽视大数据不宜用。若考优缺点，要指出层次方法对大规模数据不友好，停在这一点上能得分。另有人认为层次聚类得到全局最优也不对——层次法一旦合并就不可撤销，可能有“链锁”效应导致次优划分，只是无需迭代但不保证最佳划分。
* **簇形状局限**：K均值倾向发现**凸球形**簇（因为用均值/欧氏距离），对非球形簇效果差。考试若给例如月牙形两团数据并问K均值如何，会期待回答“K均值会错误地分割，因为它只能产生线性分割”，而DBSCAN或谱聚类可发现这两月牙为簇。所以要清楚不同算法隐含的簇形状假设：K均值/高斯混合->球形，单链层次->链状可能长蛇簇，DBSCAN->任意形状。
* **归一化**：距离计算前通常要对特征归一化以免尺度影响。有些人忘记这点，导致特征量纲不同距离计算偏向大量纲特征。答题若问“聚类准备工作”，可提“对不同尺度特征需要标准化到均值0方差1或归一化到[0,1]，否则距离主导在大尺度上”。显示对实践细节了解。

### 期末考试高频考点与建议记忆点

* **K均值流程**：务必记住K均值算法步骤及优缺点。一般以**伪代码**或叙述步骤考核，如“重复分配-更新直到收敛”。要能回答K均值时间复杂度$O(n K t)$（n样本K簇t迭代次数），优点：简单高效，缺点：需定K、局部最优、对异常点敏感（异常点会拉远中心）。这些都是提纲挈领应掌握的。
* **其他聚类算法特点**：要记得层次聚类不需K、可产出树结构，但计算耗时O($n^2$)、难修改决策；DBSCAN不用定K，可识别噪声，能找非凸簇，但高维参数难选、簇密度差异大会漏检。还有K-medoids/PAM对噪声更稳健但更慢等。如果考试列举不同算法，最好能各说一点特性以示区分。
* **距离和相似度**：可能会问“还有哪些相似性度量？”应答：如曼哈顿距离、余弦相似度、Jaccard系数（用于集合或布尔属性）等，并视数据选择。K均值一般用欧氏，文本聚类常用余弦相似（先TF-IDF向量化）。这些细节可以帮助选对算法和度量的搭配。
* **评估方法**：内部指标Silhouette可以考定义、计算例子或图形判断簇质量，外部指标Purity/NMI也可能出选择。需要了解Silhouette在(-1,1)之间，越高聚类越好；肘部法折线图拐点肉眼观察确定K。外部指标Purity= (1/N)∑ max|cluster ∩ class|。这些公式推导层面不复杂，但易记混。建议写小纸条记忆Silhouette和Purity的公式，理解涵义助于灵活应用。
* **算法应用题**：大题可能描述场景让选合适聚类法，如“电商要把用户分群做营销，用哪种聚类？” 可以说K均值（假设用户分群轮廓），因为数据量大K均值较快，又易解释簇中心。又如“地理数据中希望找任意形状聚类”，就提DBSCAN。懂得针对需求选法在主观题中很加分，也体现知识运用。复习时，想想每算法擅长的数据类型：K均值->数值球形簇；层次->小数据需要层级关系；DBSCAN->含噪声不规则簇；高斯混合->软聚类等，有的放矢回答。

## 降维与特征选择 (Dimensionality Reduction & Feature Selection)

### 核心概念和定义

* **维度灾难**：高维数据会带来计算、存储开销和模型泛化困难的问题，称为维度灾难。**降维**旨在在损失尽量少信息的前提下，将高维数据映射到低维空间，以缓解维数高带来的问题。降维可分为**特征提取**（生成新的低维特征）和**特征选择**（从原特征中挑选子集）两类。前者如PCA，将原特征线性组合成主成分；后者如选取与标签相关度最高的特征子集。降维能减少模型复杂度，提高训练速度，并可能提升模型泛化能力。
* **主成分分析(PCA)**：常用的无监督降维方法，寻找数据**方差最大**的方向作为新坐标轴。PCA本质上通过对数据协方差矩阵进行特征值分解，选取前$k$个最大特征值对应的特征向量作为主成分基底。原数据投影到这些基底上形成降维后的表示。每个主成分是原始特征的线性组合，彼此正交、不相关。PCA保证在均方误差意义下重构误差最小。广泛用于数据压缩、可视化（如高维数据投影到2D绘图）等场景。
* **线性判别分析(LDA)**：一种有监督降维方法，又称Fisher判别分析。LDA寻找能最大化类间距离与类内距离比值的投影方向。对于两类，Fisher判别向量$w$满足：$w^* = \arg\max_w \frac{w^T S_B w}{w^T S_W w}$，其中$S_B$是类间离散度矩阵，$S_W$是类内离散度矩阵。LDA将数据投影到1维时，实现两类尽可能可分；多类情况下，可降到$c-1$维（$c$类）。LDA考虑标签信息，常用于降维后再分类，能提高分类准确率。然而若类别分布非高斯或不共用协方差，LDA效果有限。
* **特征选择**：从原始特征集合中选择**最有用**的特征子集用于训练。根据选择方式分：**过滤法(Filter)**、**包裹法(Wrapper)**、**嵌入法(Embedded)**。过滤法不依赖后续学习算法，利用特征的统计指标（相关系数、信息增益、卡方值等）评分排序，选前$k$个；包裹法直接以最终模型性能为准，通过搜索（如前向选择、遗传算法）找最佳子集；嵌入法在模型训练中自动选择特征，如决策树分裂点选择了特征、L1正则会将无用特征权重缩为0。特征选择减少冗余或无关特征，简化模型并可能提高准确率。
* **应用**：降维与特征选择在高维数据（如文本、高像素图像、基因数据）处理中至关重要。PCA可用于图像压缩（如用前几十个主成分重构近似原图）、噪声滤除。特征选择在模型解释和提高效率上效果显著，如选择影响最大的若干基因进行疾病预测，能提高模型可解释性。也可用于缓解多重共线性问题。总之，这些技术让模型更简洁高效，同时可能提升泛化性能。

### 重点公式推导

* **PCA目标**：给定数据矩阵$X_{N\times d}$（已中心化），PCA寻找投影矩阵$W_{d\times k}$使得投影方差最大或重构误差最小。推导之一：最大化投影后数据协方差矩阵迹：$\max_{W^T W=I} \mathrm{Tr}(W^T S_X W)$，其最优$W$由$S_X$的前$k$大特征值的特征向量组成。推导之二：最小化重构误差$\min_W \sum_i |x_i - \hat{x}_i|^2$，也可推出同样解。详细推导涉及拉格朗日乘子或奇异值分解，理解即可。关键记忆：**PCA = 协方差矩阵特征分解**。
* **PCA求解**：协方差矩阵$S_X = \frac{1}{N}\sum (x_i - \bar{x})(x_i - \bar{x})^T$的特征值分解：$S_X = E \Lambda E^T$，$\Lambda=\mathrm{diag}(\lambda_1,\dots,\lambda_d)$且$\lambda_1\ge\dots\ge\lambda_d\ge0$。取前$k$大$\lambda$对应的$k$列特征向量构成$W$，则$Z = X W$即为降维后的$N\times k$数据矩阵。压缩后如要重构，可用$X_{approx} = Z W^T$。这个过程在教材和PPT中有算法，考试若问如何实施PCA，描述以上步骤即可。
* **选择主成分数**：常用**累计方差贡献率**决定$k$。定义贡献率$\eta(k) = \frac{\sum_{i=1}^k \lambda_i}{\sum_{i=1}^d \lambda_i}$。选取最小的$k$使$\eta(k)$超过预设阈值（如90%），即选取能解释90%方差的主成分数。或观察特征值递减图（碎石图），在拐点处截断。这不是严格公式，但要会解释：前几个主成分已含主要信息，后面特征值小的成分贡献有限，可忽略。
* **Fisher判别公式**：二类LDA目标$f(w)=\frac{w^T S_B w}{w^T S_W w}$，其中$S_B = (m_1 - m_2)(m_1 - m_2)^T$，$S_W = \sum_{i\in C_1}(x_i - m_1)(x_i - m_1)^T + \sum_{i\in C_2}(x_i - m_2)(x_i - m_2)^T$。通过对$f(w)$求导=0可得广义特征值问题：$S_W^{-1}S_B w = \lambda w$，解的最大特征值对应特征向量即最佳投影方向。多类情况$S_B = \sum_c N_c(m_c - m)(m_c - m)^T$，$S_W = \sum_c \sum_{i\in C_c}(x_i - m_c)(x_i - m_c)^T$，求$S_W^{-1} S_B$的前$C-1$个特征向量。理解LDA公式关键在于类间散布$S_B$与类内散布$S_W$比值最大化背后的分类相似原理。
* **特征选择评价指标**：Filter方法常用公式有：**信息增益**(与决策树用的一样)、**卡方统计**$\chi^2 = \sum\frac{(O-E)^2}{E}$检测特征与类别独立性、**相关系数**$r=y^T x/\sqrt{(y^Ty)(x^Tx)}$度量线性相关性等。Wrapper直接用分类准确率，没有封闭公式。Embedded以模型系数衡量，如线性回归LASSO的L1罚使不重要特征系数=0。每个公式记太多不现实，但信息增益(熵减)和相关系数这两可重点关注，因为课程讲过。
* **Relief算法**：一种常考的过滤法例子，大致思想：随机抽样一个样本，根据距离找到其同类最近邻$H$和异类最近邻$M$，然后更新特征权重：$W_j = W_j - \frac{|x_j - H_j|}{m} + \frac{|x_j - M_j|}{m}$，跑$m$次后筛选$W_j$高的特征。公式可不具体记，但需理解Relief通过近邻比较来判断特征能否区分异类（希望异类距离大）和保持同类相近（希望同类距离小）。如果考试问及Relief，描述其步骤和依据即可：特征区分度由异类/同类距离差衡量。

### 典型例题与解法简要归纳

* **示例1：手算PCA**：给出2维数据的协方差矩阵，要降到1维，让求出主成分方向。小规模例子可以直接特征值分解：解$|S-\lambda I|=0$求特征值，求对应特征向量。若算术复杂，可能提供已计算好的协方差值和特征值。需要写出最大的特征值及其特征向量，然后说明这个方向是什么意义。如果有图形直观的话，更易解释主成分方向就是数据延展最长的方向。此题锻炼计算基本功，也可能让验证降维后重构误差等。
* **示例2：选主成分数**：可能给出特征值列表或方差贡献率图表，让选择合适$k$。答题需计算累计贡献率，看何时超过阈值。如特征值分别占50%,20%,15%,10%,5%，90%阈值下需要前3个(50+20+15=85%不够，50+20+15+10=95%够了)或看图肘部在第3个开始变平等。回答要说明标准：例如“前4个主成分贡献95%，超过90%阈值，所以取4维”。有时问如“PCA如何选k”，答“使用累计方差法选择能解释足够方差的最小k”即可。
* **示例3：LDA两类投影**：给简单两类数据点，要求手画或计算最佳投影线。可以通过计算类均值、类散布，推导$w \propto (m_1 - m_2)$方向对于二类情况。事实上二类LDA解就是类均值差向量。这种题可以让学生验证投影后类间距离较大且类内方差较小。步骤：算两类均值$m_1,m_2$，取方向$w = m_1 - m_2$，对比如果取其他方向会发现类投影重叠更多。也可以让写出$S_B,S_W$并求$S_W^{-1}(m_1-m_2)$方向。总之结果要论证LDA抓住类中心差异。
* **示例4：特征选择对比**：简答题可问“三种特征选择方法的区别”。应回答：Filter过滤法独立于模型，计算简单如信息增益、相关性等；Wrapper将学习算法作为黑箱，多次训练评估组合，精度高但开销大；Embedded嵌入法在模型训练中自动选特征，如决策树选择分裂特征或带L1正则的线性模型压零权重。给出各自例子：Filter例：Relief/信息增益排序，Wrapper例：前向选择、遗传算法，Embedded例：LASSO、决策树。这样回答比较全面。
* **示例5：降维效果**：可能给一个实际场景：如“在人脸识别中为什么要用PCA降维？”答：人脸图像像素维度高且存在相关性冗余，PCA提取主要变化成分，消除噪声和冗余，降维到几十维不仅减少计算还提升识别准确率，并可视化主成分面貌。又如“为什么要做特征选择？”可以说为了去掉无关或相关性强的重复特征，降低模型过拟合风险、提升速度和可解释性。把理论与实例结合能证明对知识融会贯通，考前可想几个例子。

### 易混淆点与常见错误

* **PCA是否利用标签**：PCA是无监督的，不利用类别信息，但很多人误以为能提高分类性能就当成监督方法。要分清PCA vs LDA：PCA关心**整体最大方差**；LDA关心**类间最大分离**。若问“PCA能保证投影后可分性好吗？”应答不一定，只保证信息保留多，不考虑类别，所以用于分类可能不如LDA。回答别张冠李戴，如说PCA能最大化类间距是错误的。
* **中心化**：计算PCA前必须将数据零均值化，否则结果会偏向均值较大的方向。不做中心化的PCA特征向量可能对准原点不对称处。考试有时会问PCA步骤，别忘了**减均值**。LDA也需中心化各类数据算散布矩阵，如果实现忽略会影响计算正确性。
* **特征选择与特征提取**：混淆两者。特征提取生成新特征（可能不可解释），PCA属于此；特征选择仅选原特征子集，保持原义。有人可能说PCA是特征选择，这是不准确的，应叫降维或特征提取。考试可能问二者区别，要明确回答。
* **Wrapper局部最优**：包裹法如前向选择每步局部最优，未必全局最佳子集。一些同学不知道这点，以为前向添加就一定找到全局好子集。应知这是一种贪心近似。还有遗传算法随机，可能陷局部。答题若问“包裹法缺点”，除了计算慢也可提可能找到次优组合，因为组合空间巨大不一定全局最优。
* **过拟合风险**：Filter法没有用验证调参数，容易选到和标签偶然相关的特征导致过拟合而没被察觉。例如用信息增益过滤，高维时可能一些无关特征在训练集上恰好分布偏差有高分。这点经常被忽视。Wrapper虽然慢但用验证效果看准确率，相对避免了选错特征。如果答题问各法优缺点，可提Filter快但可能选到伪相关特征，因为不考虑模型泛化，只考虑训练统计。
* **高相关特征处理**：特征选择中，高相关的特征在Filter里可能各自评分都高但提供冗余信息。很多初学者没意识这个问题，Filter独立评估无法识别冗余。Wrapper可通过组合评估避免同时选入高度相关特征（因为一起用边际增益小）。若问“Filter与Wrapper谁更好”，就可以提到Filter无法识别特征间冗余和交互作用，Wrapper考虑模型性能可克服这点但代价高。

### 期末考试高频考点与建议记忆点

* **PCA原理与应用**：需要掌握：**PCA = 特征值分解协方差矩阵**，降维后重构误差=舍弃特征值之和。考试很可能考PCA的目标和实现，要能回答出“选取前k个主成分，使得保留数据方差最大/重构误差最小”。也要能说出PCA的一些局限：只捕获线性相关，无法处理非线性结构（可提Kernel PCA等），易受异常值影响等。
* **LDA和PCA比较**：高频问答，记住：LDA监督，考虑类别区分；PCA无监督，只管方差。LDA降维最多到C-1维，PCA可任意降。LDA需要满秩$S_W$，类别正态分布假设，样本小维高时不稳。可以准备一个对比表，考试让论述就不慌了。
* **三种特征选择法**：Filter/Wrapper/Embedded定义和例子，可能会以选择题或判断题形式考其特点。例如“决策树的特征选择属于嵌入法（对）”、“前向逐步回归是Wrapper（对）”、“Relief是Wrapper（错，是Filter）”等。确保能分类典型方法以防混淆。
* **特征选择评价指标**：信息增益和卡方统计、相关系数这些定义可能要知道。至少信息增益=父节点熵-各子集加权熵这个公式在决策树讲过，应能识别。卡方如给个表，让计算$\chi^2$值判断关联显著性，原理课上也讲过。NMI等外部指标可能也涉及简单计算（例如给个聚类结果和真标签计算互信息），但偏概念。
* **综合应用**：有时综合题会给出一个机器学习pipeline示意图，包括先做PCA再分类，或先筛选特征再训练模型，让解释这么做的意义。比如“为什么在SVM前用PCA？”回答：降维去噪，减少特征数提升SVM速度，并可能去除相关特征提高泛化。平时多想这样的问题，有助应对考卷上的类似开放问答。总之要认识到降维/特征选择是整个机器学习流程的一部分，不能脱节理解。